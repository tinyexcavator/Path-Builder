<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>Path Builder — Two-Player Strategy</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#11161d;
      --text:#e8f0ff;
      --muted:#8aa0b3;
      --blue:#45a3ff;
      --orange:#ff9b3c;
      --accent:#30ffd0;
      --warning:#ff5c7a;
      --wood1:#5e3b1c;
      --wood2:#8a5525;
      --wood3:#c0894e;
      --cell: #1b2230;
      --grid-gap: 7px;
      --board-size: min(88vw, 72vh);
      --cell-radius: 10px;
      --shadow: 0 8px 24px rgba(0,0,0,.35);
    }

    html,body{height:100%}
    body{
      margin:0; background: radial-gradient(1200px 800px at 20% 0%, #101828, #0b0f14 70%);
      color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      display:flex; align-items:center; justify-content:center; padding:16px;
    }

    .wrap{width:100%; max-width:1200px; display:grid; gap:14px; grid-template-columns: 1fr; }
    header{display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap}
    .title{display:flex; align-items:center; gap:12px; font-weight:700; letter-spacing:.3px}
    .title .logo{
      width:36px; height:36px; border-radius:10px; background:
      conic-gradient(from 210deg, #1b2330, #3d5b7f, #1b2330);
      box-shadow: inset 0 0 12px #8dd8ff66, 0 6px 18px #0008;
      position:relative;
    }
    .title .logo:after{
      content:""; position:absolute; inset:6px; border-radius:8px;
      background: radial-gradient(120% 120% at 30% 25%, #59c0ff, #18314a 60%, #0e1826 100%);
      filter:brightness(1.1) contrast(1.05);
    }

    .status{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      background: linear-gradient(180deg, #0f141b, #0b1117);
      border:1px solid #1b2430; border-radius:12px; padding:10px 12px; box-shadow: var(--shadow);
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:999px;
      background:#121a24; border:1px solid #223042; color:var(--muted); font-weight:600
    }
    .pill .dot{width:12px; height:12px; border-radius:50%}
    .dot.blue{background:radial-gradient(circle at 35% 30%, #9ed2ff, #45a3ff 60%, #1f4b80)}
    .dot.orange{background:radial-gradient(circle at 35% 30%, #ffd1a1, #ff9b3c 60%, #7b3b06)}
    .dash{opacity:.35}

    .controls{display:flex; gap:8px; flex-wrap:wrap}
    button{
      appearance:none; border:none; cursor:pointer; color:#eaf4ff; font-weight:700; letter-spacing:.2px;
      padding:10px 14px; border-radius:10px; background:
      linear-gradient(180deg, #1a2430, #121923);
      border:1px solid #243244; box-shadow: var(--shadow);
    }
    button:disabled{opacity:.5; cursor:not-allowed}
    .primary{background:linear-gradient(180deg, #1e2f3f, #14202b); border-color:#35506b}
    .danger{background:linear-gradient(180deg, #2a1820, #1e1016); border-color:#5e3040}
    .ghost{background:linear-gradient(180deg, #121820, #0e141a); border-color:#222e3d}
    .toggle{display:flex; align-items:center; gap:8px}
    .toggle input{transform:scale(1.2)}

    /* Board container */
    .board-wrap{
      display:grid; grid-template-columns: var(--board-size) 1fr; gap:16px;
    }
    @media (max-width: 900px){
      .board-wrap{grid-template-columns: 1fr}
    }

    /* Wood board */
    .board{
      width:var(--board-size); height:var(--board-size);
      border-radius:18px; padding:18px; box-shadow: 0 16px 40px rgba(0,0,0,.5);
      background:
        linear-gradient(115deg, #0006, #0000 20% 80%, #0006),
        repeating-linear-gradient( 8deg, var(--wood1), var(--wood1) 14px, var(--wood2) 14px, var(--wood2) 28px),
        radial-gradient(120% 120% at 10% 10%, #00000070, #0000 40%),
        radial-gradient(120% 120% at 90% 90%, #00000070, #0000 40%),
        linear-gradient(180deg, #2d1a0c, #2d1a0c);
      position:relative; overflow:hidden;
    }
    .inlay{
      position:absolute; inset:12px; border-radius:14px;
      border:2px solid #2d1a0c; box-shadow: inset 0 0 0 2px #0006, inset 0 0 24px #0006;
      pointer-events:none;
    }

    .grid{
      position:absolute; inset:26px; display:grid; gap:var(--grid-gap);
      /* 9x9 grid; change --n if you want a different size */
      --n: 9;
      grid-template-columns: repeat(var(--n), 1fr);
      grid-template-rows: repeat(var(--n), 1fr);
    }
    .cell{
      border-radius: var(--cell-radius);
      background:
        linear-gradient(180deg, #0a0f15, #0c131b 40%, #0a0f15 100%);
      border:1px solid #1b2531;
      box-shadow: inset 0 2px 1px #2a3646, inset 0 -2px 2px #070b10, 0 1px 0 #0008;
      position:relative; touch-action: manipulation;
    }
    .cell.legal{ outline:2px solid #2dc7ffaa; outline-offset: -2px; }
    .cell.winning{ animation: pulse 1.1s ease-in-out infinite }
    @keyframes pulse{0%,100%{box-shadow:0 0 0 0 #30ffd040, inset 0 2px 1px #2a3646, inset 0 -2px 2px #070b10}50%{box-shadow:0 0 0 10px #30ffd000, inset 0 2px 1px #2a3646, inset 0 -2px 2px #070b10}}

    /* Stacks */
    .stack{
      position:absolute; inset:6%; display:flex; flex-direction:column; justify-content:flex-end; align-items:center; gap:6%;
      pointer-events:none;
    }
    .disc{
      width:100%; aspect-ratio:1/1; border-radius:50%;
      background: radial-gradient(120% 120% at 30% 25%, #b6d8ff, #4aa7ff, #1f4774 70%, #0d1f33 100%);
      border:1px solid #82c7ff;
      box-shadow:
        inset 0 4px 10px #ffffff50,
        inset 0 -6px 10px #000000b0,
        0 4px 10px rgba(0,0,0,.6);
      filter:saturate(1.05) brightness(1.02) contrast(1.05);
    }
    .disc.orange{
      background: radial-gradient(120% 120% at 30% 25%, #ffd9b1, #ffa64e, #7b3b06 70%, #2a1200 100%);
      border-color:#ffc48a;
    }
    .disc.shadow{opacity:.5; filter: blur(0.2px) brightness(.8)}

    /* Right panel */
    .side{
      display:grid; gap:12px; align-content:start;
    }
    .card{
      background: linear-gradient(180deg, #0f141b, #0b1117);
      border:1px solid #1b2430; border-radius:12px; padding:12px; box-shadow: var(--shadow);
    }
    .row{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap}
    .stat{color:var(--muted); font-weight:600}
    .big{font-size:20px; color:var(--text); font-weight:800}

    .footer{color:#7d93a8; font-size:12px; text-align:center; opacity:.8}
    .link{color:#a8d8ff}

    /* Last move highlight ring */
    .last-ring{
      position:absolute; inset:0; border-radius: var(--cell-radius);
      outline:3px solid #30ffd0; outline-offset:-3px; box-shadow: 0 0 18px #30ffd088; pointer-events:none;
      animation: fade 1.8s ease-out forwards;
    }
    @keyframes fade{0%{opacity:1}100%{opacity:0}}

    /* Edge goals indicator bars */
    .edge{
      position:absolute; pointer-events:none; opacity:.7;
      filter: drop-shadow(0 4px 10px #000a);
    }
    .edge.h.left{left: 22px; top:26px; bottom:26px; width:10px; background:linear-gradient(90deg, #46a6ff, #1a5ba5)}
    .edge.h.right{right: 22px; top:26px; bottom:26px; width:10px; background:linear-gradient(90deg, #1a5ba5, #46a6ff)}
    .edge.v.top{top: 22px; left:26px; right:26px; height:10px; background:linear-gradient(180deg, #a55a14, #ff9b3c)}
    .edge.v.bottom{bottom: 22px; left:26px; right:26px; height:10px; background:linear-gradient(180deg, #ff9b3c, #a55a14)}

    /* Toast */
    .toast{
      position:fixed; left:50%; bottom:16px; transform:translateX(-50%);
      background:#0d1420; border:1px solid #27374d; color:#d8e6ff;
      padding:10px 14px; border-radius:10px; box-shadow: var(--shadow); opacity:0; pointer-events:none;
      transition:.25s ease;
    }
    .toast.show{opacity:1; transform:translateX(-50%) translateY(-6px)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <div style="font-size:18px; font-weight:800">Path Builder</div>
          <div style="font-size:12px; color:var(--muted)">Two-player tactical stacking — first to connect wins</div>
        </div>
      </div>

      <div class="status">
        <div class="pill" id="turnPill" aria-live="polite" aria-atomic="true">
          <span class="dot blue"></span>
          <span id="turnText">Blue to move</span>
        </div>
        <div class="pill">
          <span class="stat">Timer:</span> <span class="big" id="timer">00:00</span>
        </div>
        <div class="pill">
          <span class="stat">Blue (L↔R)</span><span class="dash">/</span><span class="stat">Orange (T↕B)</span>
        </div>
      </div>

      <div class="controls">
        <button class="primary" id="undoBtn" title="Undo (⌘/Ctrl+Z)" disabled>Undo</button>
        <button class="ghost" id="redoBtn" title="Redo (⌘/Ctrl+Shift+Z)" disabled>Redo</button>
        <button class="ghost" id="swapBtn" title="After Blue’s first move, Orange may swap sides" disabled>Swap Sides</button>
        <button class="danger" id="resetBtn" title="Reset (R)">Reset</button>
        <label class="toggle pill"><input type="checkbox" id="legalToggle" /> Show legal moves</label>
        <label class="toggle pill"><input type="checkbox" id="sfxToggle" checked /> SFX</label>
      </div>
    </header>

    <div class="board-wrap">
      <div class="board" id="board" role="application" aria-label="Game board">
        <div class="inlay"></div>
        <!-- Edge goals -->
        <div class="edge h left" title="Blue connects left ↔ right"></div>
        <div class="edge h right" title="Blue connects left ↔ right"></div>
        <div class="edge v top" title="Orange connects top ↕ bottom"></div>
        <div class="edge v bottom" title="Orange connects top ↕ bottom"></div>

        <div class="grid" id="grid" style="--n:9"></div>
      </div>

      <aside class="side">
        <div class="card">
          <div class="row">
            <div class="stat">Top control</div>
            <div><span class="big" id="blueCount">0</span> <span class="muted">Blue</span> &nbsp;•&nbsp; <span class="big" id="orangeCount">0</span> <span class="muted">Orange</span></div>
          </div>
          <div style="margin-top:8px;color:#98aec2;font-size:13px">
            First to connect their sides wins. If the board fills with no connection, higher top-control wins.
          </div>
        </div>

        <div class="card">
          <div class="row">
            <div class="stat">Last move</div>
            <div id="lastMove" class="big">—</div>
          </div>
          <div style="margin-top:8px;color:#98aec2;font-size:13px">
            Max stack height is 2. Only the top block controls a cell.
          </div>
        </div>

        <div class="footer">
          Tip: Orange can use <span style="color:#ffd38f">Swap Sides</span> right after Blue’s first move to counter first-move advantage.<br/>
          Built for touch + mouse. Works offline. No libraries.
        </div>
      </aside>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite" aria-atomic="true"></div>

  <script>
    /**************
     * Config
     **************/
    const N = 9;                 // grid size (NxN). 9 gives good 4–8 min matches.
    const MAX_HEIGHT = 2;        // max stack height per cell
    const BLUE = 1, ORANGE = 2;  // players
    const SHOW_LEGAL_DEFAULT = false;

    /**************
     * State
     **************/
    const gridEl = document.getElementById('grid');
    const boardEl = document.getElementById('board');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const swapBtn = document.getElementById('swapBtn');
    const resetBtn = document.getElementById('resetBtn');
    const turnPill = document.getElementById('turnPill');
    const turnText = document.getElementById('turnText');
    const blueCountEl = document.getElementById('blueCount');
    const orangeCountEl = document.getElementById('orangeCount');
    const lastMoveEl = document.getElementById('lastMove');
    const timerEl = document.getElementById('timer');
    const legalToggle = document.getElementById('legalToggle');
    const sfxToggle = document.getElementById('sfxToggle');
    const toastEl = document.getElementById('toast');

    let cells = []; // each cell: {h:0..2, top:0|1|2}
    let turn = BLUE;
    let moveNumber = 0;
    let swapAvailable = false;   // true only for Orange right after Blue’s first move
    let swapped = false;         // whether sides have been swapped
    let history = [];
    let future = [];
    let startTime = Date.now();
    let timerInt = null;

    // DSU (union-find) for each player to check connections quickly
    function DSU(n){
      this.p = Array(n).fill(0).map((_,i)=>i);
      this.r = Array(n).fill(0);
      this.find = (x)=> this.p[x]===x?x:(this.p[x]=this.find(this.p[x]));
      this.union = (a,b)=>{
        a=this.find(a); b=this.find(b);
        if(a===b) return;
        if(this.r[a]<this.r[b]) [a,b]=[b,a];
        this.p[b]=a; if(this.r[a]===this.r[b]) this.r[a]++;
      }
    }

    // index helpers
    const idx = (r,c)=> r*N + c;

    // Build DOM grid
    function buildGrid(){
      gridEl.innerHTML = '';
      gridEl.style.setProperty('--n', N);
      cells = Array(N*N).fill(0).map(()=>({h:0, top:0}));

      for(let r=0;r<N;r++){
        for(let c=0;c<N;c++){
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.setAttribute('role','button');
          cell.setAttribute('aria-label', `Cell ${r+1}, ${c+1}`);
          cell.dataset.r = r; cell.dataset.c = c;
          const stack = document.createElement('div');
          stack.className = 'stack';
          cell.appendChild(stack);
          cell.addEventListener('click', onCell);
          cell.addEventListener('touchstart', (e)=>{ e.preventDefault(); onCell(e); }, {passive:false});
          gridEl.appendChild(cell);
        }
      }
      drawAll();
    }

    // Draw one cell
    function drawCell(r,c){
      const i = idx(r,c);
      const state = cells[i];
      const el = gridEl.children[i];
      const stack = el.querySelector('.stack');
      stack.innerHTML = '';

      if(state.h>0){
        // bottom disc renders as subtle shadow for depth
        const bottom = document.createElement('div');
        bottom.className = 'disc shadow ' + (state.h>=1 ? (state.top===BLUE?'orange':'blue') : '');
        bottom.style.opacity = state.h===2 ? .4 : .0; // only show if 2-high
        stack.appendChild(bottom);
      }
      if(state.h>0){
        const topDisc = document.createElement('div');
        topDisc.className = 'disc ' + (state.top===BLUE ? '' : 'orange');
        stack.appendChild(topDisc);
      }
    }

    function drawAll(){
      for(let r=0;r<N;r++) for(let c=0;c<N;c++) drawCell(r,c);
      updateCounts();
      updateLegalHints();
    }

    function updateCounts(){
      let b=0,o=0;
      for(const cell of cells){
        if(cell.top===BLUE && cell.h>0) b++;
        if(cell.top===ORANGE && cell.h>0) o++;
      }
      blueCountEl.textContent = b;
      orangeCountEl.textContent = o;
    }

    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      clearTimeout(toast._t);
      toast._t = setTimeout(()=>toastEl.classList.remove('show'), 1600);
    }

    /**************
     * Audio (tiny SFX using WebAudio)
     **************/
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let ac = null;
    function ensureAudio(){
      if(ac || !sfxToggle.checked) return;
      try{ ac = new AudioCtx(); }catch(e){}
    }
    function beep(freq=660, dur=0.06, type='sine', gain=0.06){
      if(!sfxToggle.checked) return;
      ensureAudio(); if(!ac) return;
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g).connect(ac.destination);
      o.start();
      o.stop(ac.currentTime + dur);
    }
    function chordWin(){
      if(!sfxToggle.checked){ return; }
      ensureAudio(); if(!ac) return;
      [523,659,784].forEach((f,i)=>{
        setTimeout(()=>beep(f,0.18,'sine',0.07), i*60);
      });
    }

    /**************
     * Game logic
     **************/
    function currentPlayerName(){ return turn===BLUE?'Blue':'Orange'; }

    function setTurn(t){
      turn = t;
      turnText.textContent = `${currentPlayerName()} to move`;
      turnPill.querySelector('.dot').className = 'dot ' + (turn===BLUE?'blue':'orange');
    }

    function place(r,c){
      const i = idx(r,c);
      const cell = cells[i];
      if(cell.h>=MAX_HEIGHT) return false;

      // record previous for undo
      history.push({r,c, prev:{h:cell.h, top:cell.top}, turn, moveNumber, swapped});
      future.length = 0; // clear redo after new move
      undoBtn.disabled = false; redoBtn.disabled = true;

      // place
      cell.h += 1;
      cell.top = (cell.h>0)? turn : 0;
      moveNumber++;

      // update last move ring
      highlightLastMove(r,c);

      // SFX
      beep(turn===BLUE? 720 : 520, 0.05, 'triangle', 0.06);

      // Swap option: after Blue’s *first* move, Orange may swap
      if(moveNumber===1 && turn===BLUE){
        swapAvailable = true;
        swapBtn.disabled = false;
      }else{
        swapBtn.disabled = true;
      }

      drawCell(r,c);
      updateCounts();

      // Check win
      const win = checkWin();
      if(win){
        finish(win);
        return true;
      }

      // If board full, tiebreaker
      if(fullBoard()){
        const winner = tiebreakerWinner();
        finish(winner, true);
        return true;
      }

      // Next turn
      setTurn(turn===BLUE? ORANGE : BLUE);
      updateLegalHints();
      updateLastMoveText(r,c);
      return true;
    }

    function highlightLastMove(r,c){
      // remove any existing rings
      for(const el of gridEl.querySelectorAll('.last-ring')) el.remove();
      const el = gridEl.children[idx(r,c)];
      const ring = document.createElement('div');
      ring.className = 'last-ring';
      el.appendChild(ring);
    }

    function updateLastMoveText(r,c){
      lastMoveEl.textContent = `${currentPlayerName()==='Blue'?'Orange':'Blue'} → r${r+1},c${c+1}`;
    }

    function onCell(e){
      const target = e.currentTarget;
      const r = +target.dataset.r, c = +target.dataset.c;
      const i = idx(r,c);
      if(gameOver) return;
      if(cells[i].h>=MAX_HEIGHT){ beep(220,0.05,'sawtooth',0.04); return; }
      place(r,c);
    }

    // Undo / Redo
    function undo(){
      if(!history.length || gameOver) return;
      const step = history.pop();
      const i = idx(step.r, step.c);
      const cell = cells[i];
      // push to future for redo
      future.push({
        r: step.r, c: step.c,
        next: {h: cell.h, top: cell.top},
        turnWas: turn, moveNumberWas: moveNumber, swappedWas: swapped
      });

      // restore
      cells[i] = {...step.prev};
      moveNumber = step.moveNumber;
      swapped = step.swapped;
      setTurn(step.turn); // restore the player who was to move for that step

      // Clear any win marking
      clearWinning();

      drawCell(step.r, step.c);
      updateCounts();
      updateLegalHints();

      // status buttons
      undoBtn.disabled = history.length===0;
      redoBtn.disabled = false;
      swapAvailable = (moveNumber===1 && turn===ORANGE && !swapped);
      swapBtn.disabled = !swapAvailable;

      beep(360,0.05,'square',0.05);
      updateLastMoveAfterUndo();
      gameOver = false;
    }
    function redo(){
      if(!future.length || gameOver) return;
      const step = future.pop();
      const i = idx(step.r, step.c);
      // record current to history
      history.push({r: step.r, c: step.c, prev:{...cells[i]}, turn, moveNumber, swapped});
      // apply
      cells[i] = {...step.next};
      turn = step.turnWas;
      moveNumber = step.moveNumberWas;
      swapped = step.swappedWas;

      drawCell(step.r, step.c);
      updateCounts();
      updateLegalHints();

      undoBtn.disabled = false;
      redoBtn.disabled = future.length===0;

      // swap availability recalculation
      swapAvailable = (moveNumber===1 && turn===ORANGE && !swapped);
      swapBtn.disabled = !swapAvailable;

      beep(500,0.05,'square',0.05);
      updateLastMoveAfterUndo();
    }
    function updateLastMoveAfterUndo(){
      if(!history.length){ lastMoveEl.textContent = '—'; return; }
      const {r,c} = history[history.length-1];
      lastMoveEl.textContent = `r${r+1},c${c+1}`;
      highlightLastMove(r,c);
    }

    // Swap sides (Pie rule)
    function swapSides(){
      if(!swapAvailable || turn!==ORANGE || moveNumber!==1 || swapped) return;
      swapped = true;
      swapAvailable = false;
      swapBtn.disabled = true;
      toast("Sides swapped: Orange now connects L↔R; Blue connects T↕B.");
      beep(600,0.05); setTimeout(()=>beep(520,0.05),80);
      drawAll(); // purely visual text remains the same, goal logic uses `swapped`
    }

    // Reset
    function reset(){
      gameOver=false;
      moveNumber=0; swapped=false; swapAvailable=false;
      history.length=0; future.length=0;
      undoBtn.disabled = true; redoBtn.disabled = true; swapBtn.disabled = true;
      setTurn(BLUE);
      buildGrid();
      lastMoveEl.textContent = '—';
      startTimer();
      clearWinning();
      toast('New game');
      beep(560,0.06); setTimeout(()=>beep(420,0.06),70);
    }

    // Full board?
    function fullBoard(){ return cells.every(c=>c.h>=MAX_HEIGHT); }

    // Tiebreaker
    function tiebreakerWinner(){
      let b=0,o=0;
      for(const c of cells){
        if(c.top===BLUE && c.h>0) b++;
        if(c.top===ORANGE && c.h>0) o++;
      }
      if(b>o) return BLUE;
      if(o>b) return ORANGE;
      return 0; // absolute tie
    }

    // Build DSU for a player based on top control
    // For connectivity, we connect orthogonally (N,E,S,W).
    function buildDSU(player){
      // +2 virtual nodes for edges to check span
      const VIRTUAL_A = N*N;     // left or top
      const VIRTUAL_B = N*N + 1; // right or bottom
      const dsu = new DSU(N*N + 2);

      for(let r=0;r<N;r++){
        for(let c=0;c<N;c++){
          const i = idx(r,c);
          if(cells[i].top!==player) continue;
          // union with neighbors of same player
          const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
          for(const [dr,dc] of dirs){
            const nr=r+dr, nc=c+dc;
            if(nr<0||nr>=N||nc<0||nc>=N) continue;
            const j = idx(nr,nc);
            if(cells[j].top===player) dsu.union(i, j);
          }
          // union with virtual edges
          if(!swapped){
            if(player===BLUE){
              if(c===0) dsu.union(i, VIRTUAL_A);
              if(c===N-1) dsu.union(i, VIRTUAL_B);
            }else{ // ORANGE
              if(r===0) dsu.union(i, VIRTUAL_A);
              if(r===N-1) dsu.union(i, VIRTUAL_B);
            }
          }else{
            // swapped roles
            if(player===ORANGE){
              if(c===0) dsu.union(i, VIRTUAL_A);
              if(c===N-1) dsu.union(i, VIRTUAL_B);
            }else{ // BLUE now top↕bottom when swapped
              if(r===0) dsu.union(i, VIRTUAL_A);
              if(r===N-1) dsu.union(i, VIRTUAL_B);
            }
          }
        }
      }
      return {dsu, A:N*N, B:N*N+1};
    }

    function checkWin(){
      // Check both players each move; small board, cheap
      for(const p of [BLUE, ORANGE]){
        const {dsu, A, B} = buildDSU(p);
        if(dsu.find(A)===dsu.find(B)) return p;
      }
      return 0;
    }

    let gameOver = false;
    function finish(winner, viaTiebreak=false){
      gameOver = true;
      if(winner===0){
        toast("Tie game");
      }else{
        const who = (winner===BLUE?'Blue':'Orange');
        turnText.textContent = `${who} wins` + (viaTiebreak?' (tiebreaker)':'');
        highlightWinningPath(winner);
        chordWin();
        toast(`${who} wins` + (viaTiebreak?' — tiebreaker':'') );
      }
      undoBtn.disabled = false; // allow reviewing / undoing after finish
      swapBtn.disabled = true;
    }

    // Highlight a winning path (greedy BFS from one edge to the other)
    function highlightWinningPath(player){
      const visited = new Set();
      const q = [];
      const parent = new Map();
      const isOwned = (r,c)=> cells[idx(r,c)].top===player;

      const push = (r,c)=>{ const k=idx(r,c); visited.add(k); q.push([r,c]); };

      if(!swapped){
        if(player===BLUE){
          for(let r=0;r<N;r++) if(isOwned(r,0)) push(r,0);
        }else{
          for(let c=0;c<N;c++) if(isOwned(0,c)) push(0,c);
        }
      }else{
        if(player===ORANGE){ // now L↔R
          for(let r=0;r<N;r++) if(isOwned(r,0)) push(r,0);
        }else{ // BLUE now T↕B
          for(let c=0;c<N;c++) if(isOwned(0,c)) push(0,c);
        }
      }

      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      let end=null;
      while(q.length){
        const [r,c]=q.shift();
        const k=idx(r,c);
        // check goal reached
        if(!swapped){
          if(player===BLUE && c===N-1){ end=[r,c]; break; }
          if(player===ORANGE && r===N-1){ end=[r,c]; break; }
        }else{
          if(player===ORANGE && c===N-1){ end=[r,c]; break; }
          if(player===BLUE && r===N-1){ end=[r,c]; break; }
        }
        for(const [dr,dc] of dirs){
          const nr=r+dr, nc=c+dc;
          if(nr<0||nr>=N||nc<0||nc>=N) continue;
          const j=idx(nr,nc);
          if(visited.has(j)) continue;
          if(!isOwned(nr,nc)) continue;
          visited.add(j);
          parent.set(j,k);
          q.push([nr,nc]);
        }
      }
      if(!end) return;
      // backtrack and mark winning cells
      let [r,c]=end;
      while(true){
        const k = idx(r,c);
        gridEl.children[k].classList.add('winning');
        if(!parent.has(k)) break;
        const p = parent.get(k);
        r = Math.floor(p/N); c = p%N;
      }
    }
    function clearWinning(){
      for(const el of gridEl.children){ el.classList.remove('winning'); }
    }

    function updateLegalHints(){
      const show = legalToggle.checked;
      for(let i=0;i<gridEl.children.length;i++){
        const el = gridEl.children[i];
        const legal = cells[i].h < MAX_HEIGHT && !gameOver;
        el.classList.toggle('legal', show && legal);
      }
    }

    /**************
     * Timer
     **************/
    function startTimer(){
      startTime = Date.now();
      if(timerInt) clearInterval(timerInt);
      timerInt = setInterval(()=>{
        const s = Math.floor((Date.now()-startTime)/1000);
        const m = Math.floor(s/60);
        const ss = String(s%60).padStart(2,'0');
        timerEl.textContent = `${String(m).padStart(2,'0')}:${ss}`;
      }, 250);
    }

    /**************
     * Events
     **************/
    undoBtn.addEventListener('click', undo);
    redoBtn.addEventListener('click', redo);
    resetBtn.addEventListener('click', reset);
    swapBtn.addEventListener('click', swapSides);
    legalToggle.checked = SHOW_LEGAL_DEFAULT;
    legalToggle.addEventListener('change', updateLegalHints);
    sfxToggle.addEventListener('change', ()=>{ if(sfxToggle.checked) ensureAudio(); });

    // Keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      const mac = navigator.platform.toUpperCase().includes('MAC');
      const mod = mac ? e.metaKey : e.ctrlKey;
      if(mod && e.key.toLowerCase()==='z' && !e.shiftKey){ e.preventDefault(); undo(); }
      else if(mod && e.key.toLowerCase()==='z' && e.shiftKey){ e.preventDefault(); redo(); }
      else if(e.key.toLowerCase()==='r'){ e.preventDefault(); reset(); }
    });

    /**************
     * Init
     **************/
    buildGrid();
    setTurn(BLUE);
    startTimer();

    // first user gesture prepares audio (iOS)
    ['touchstart','mousedown'].forEach(ev=>{
      window.addEventListener(ev, ()=>ensureAudio(), {once:true, passive:true});
    });

  </script>
</body>
</html>

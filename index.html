<!-- in your <head> or just before your game script -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>


<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Roller Glow — 3D Prototype</title>
<style>
  html,body{height:100%;margin:0;background:#0b0f14;color:#e8f0ff;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto}
  #ui{position:fixed;inset:auto 12px 12px 12px;display:flex;gap:8px;align-items:center;justify-content:space-between;pointer-events:none}
  .card{pointer-events:auto;background:rgba(16,22,30,.7);backdrop-filter:blur(6px);border:1px solid #203040;border-radius:12px;padding:8px 10px;box-shadow:0 6px 24px rgba(0,0,0,.35)}
  .btn{cursor:pointer;border:1px solid #2f445c;border-radius:10px;background:linear-gradient(180deg,#1a2430,#121923);color:#eaf4ff;font-weight:700;padding:8px 12px}
  .btn:disabled{opacity:.4;cursor:not-allowed}
  .hint{opacity:.8;font-size:12px}
  #levelName{font-weight:800}
  canvas{display:block}
</style>
<!-- Three.js CDN -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
<div id="ui">
  <div class="card">
    <span>LEVEL <span id="levelName">1</span> / 5</span>
    <button id="prevBtn" class="btn">Prev</button>
    <button id="nextBtn" class="btn">Next</button>
    <button id="resetBtn" class="btn">Reset</button>
  </div>
  <div class="card hint">
    Mouse drag = rotate • Wheel = zoom • Arrows = move • Space = up • Shift = down
  </div>
</div>

<script>
/* ---------- scene / camera / renderer ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0f14);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(20, 18, 24);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

/* ---------- controls ---------- */
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.rotateSpeed = 0.8;
controls.minDistance = 8;
controls.maxDistance = 80;

/* ---------- lights ---------- */
scene.add(new THREE.AmbientLight(0x8899aa, 0.6));
const key = new THREE.DirectionalLight(0xffffff, 0.8);
key.position.set(10,20,10);
key.castShadow = true;
key.shadow.mapSize.set(1024,1024);
scene.add(key);
const rim = new THREE.DirectionalLight(0x66aaff, 0.35);
rim.position.set(-12,12,-8);
scene.add(rim);

/* ---------- arena bounds ---------- */
const ARENA = { x: 24, y: 14, z: 36 }; // half-extents
const floorMat = new THREE.MeshPhysicalMaterial({
  color: 0x0e1620, metalness: 0.5, roughness: 0.65,
  transmission: 0, clearcoat: 1, clearcoatRoughness: 0.4
});
const floor = new THREE.Mesh(new THREE.BoxGeometry(ARENA.x*2, 1, ARENA.z*2), floorMat);
floor.position.y = -0.5;
floor.receiveShadow = true;
scene.add(floor);

/* Glassy walls (semi-transparent so you can see through) */
const glassMat = new THREE.MeshPhysicalMaterial({
  color: 0x84a9ff, metalness: 0.2, roughness: 0.15,
  transmission: 0.6, transparent: true, opacity: 0.35, thickness: 0.6,
  ior: 1.25
});
function makeWall(w,h,d,x,y,z){
  const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), glassMat);
  m.position.set(x,y,z);
  m.castShadow = true;
  m.receiveShadow = true;
  scene.add(m);
  return m;
}

/* ---------- ball ---------- */
const ballRadius = 1.2;
const ballMat = new THREE.MeshPhysicalMaterial({
  color: 0x45a3ff,
  metalness: 1, roughness: 0.15, clearcoat: 1, clearcoatRoughness: 0.06,
  sheen: 1, sheenRoughness: 0.2, sheenColor: new THREE.Color(0xcfe6ff)
});
const ball = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 48, 32), ballMat);
ball.position.set(0, ballRadius, -ARENA.z + 4);
ball.castShadow = true;
scene.add(ball);

/* subtle inner glow on ball */
const glow = new THREE.PointLight(0x46c0ff, 0.8, 12);
ball.add(glow);

/* ---------- camera follows ball ---------- */
controls.target.copy(ball.position);

/* ---------- trail system (fading sprites) ---------- */
const trailTex = (()=>{ // tiny radial gradient canvas
  const s=128, c=document.createElement('canvas'); c.width=c.height=s;
  const g=c.getContext('2d');
  const r=s/2; const grd=g.createRadialGradient(r,r,0, r,r,r);
  grd.addColorStop(0,'rgba(120,220,255,0.9)');
  grd.addColorStop(0.5,'rgba(80,180,255,0.35)');
  grd.addColorStop(1,'rgba(0,0,0,0)');
  g.fillStyle=grd; g.fillRect(0,0,s,s); 
  const tex=new THREE.CanvasTexture(c); tex.minFilter=THREE.LinearFilter; return tex;
})();
const trailGroup = new THREE.Group(); scene.add(trailGroup);
const trailPool = [];
function spawnTrail(){
  const s = 0.9 + Math.random()*0.5;
  const mat = new THREE.SpriteMaterial({ map: trailTex, transparent:true, depthWrite:false });
  const spr = new THREE.Sprite(mat);
  spr.scale.setScalar(s);
  spr.position.copy(ball.position);
  spr.position.y -= (ballRadius-0.2); // near ground by default
  spr.userData.life = 0.9; // seconds
  spr.userData.velY = 0.0;
  trailGroup.add(spr);
  trailPool.push(spr);
}

/* ---------- input ---------- */
const keys = new Set();
window.addEventListener('keydown', e=>{
  if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' ','Shift'].includes(e.key)) e.preventDefault();
  keys.add(e.key);
});
window.addEventListener('keyup', e=> keys.delete(e.key));

/* ---------- simple physics ---------- */
let vel = new THREE.Vector3();
const accel = 22;             // movement acceleration
const drag = 0.88;            // velocity damping per frame
const maxSpeed = 12;
const bounce = 0.55;          // restitution on wall hit
let squash = 0;               // for squash & stretch animation

/* ---------- levels (5 layouts) ---------- */
const levels = [
  // Level 1: Open box + a few posts
  (group)=>{
    group.add(makeWall(ARENA.x*2, 10, 0.8, 0, 4.5, -ARENA.z+0.4));
    group.add(makeWall(ARENA.x*2, 10, 0.8, 0, 4.5,  ARENA.z-0.4));
    group.add(makeWall(0.8, 10, ARENA.z*2, -ARENA.x+0.4, 4.5, 0));
    group.add(makeWall(0.8, 10, ARENA.z*2,  ARENA.x-0.4, 4.5, 0));
    // posts
    group.add(makeWall(2,6,2, -6,3,-10));
    group.add(makeWall(2,6,2,  6,3,-2));
    group.add(makeWall(2,6,2,  0,3, 8));
  },
  // Level 2: Two-story corridors
  (group)=>{
    levels[0](group);
    group.add(makeWall(16,2,2, 0,2, -6));
    group.add(makeWall(16,2,2, 0,6,  6));
    group.add(makeWall(2,8,10, -8,4, 0));
    group.add(makeWall(2,8,10,  8,4, 0));
  },
  // Level 3: Floating bridges
  (group)=>{
    levels[0](group);
    group.add(makeWall(10,2,2, -8,8,-6));
    group.add(makeWall(10,2,2,  8,10,0));
    group.add(makeWall(10,2,2,  0,7,8));
  },
  // Level 4: Glass labyrinth
  (group)=>{
    levels[0](group);
    for(let z=-12; z<=12; z+=6){
      group.add(makeWall(18,2,0.6, 0, 3, z));
      group.add(makeWall(18,2,0.6, 0, 7, z+3));
    }
    group.add(makeWall(0.6,8,18, -6,4, 0));
    group.add(makeWall(0.6,8,18,  6,4, 0));
  },
  // Level 5: Hollow cube core
  (group)=>{
    group.add(makeWall(ARENA.x*2, 10, 0.8, 0, 4.5, -ARENA.z+0.4));
    group.add(makeWall(ARENA.x*2, 10, 0.8, 0, 4.5,  ARENA.z-0.4));
    group.add(makeWall(0.8, 10, ARENA.z*2, -ARENA.x+0.4, 4.5, 0));
    group.add(makeWall(0.8, 10, ARENA.z*2,  ARENA.x-0.4, 4.5, 0));
    // cube frame in middle
    const s=10, t=0.8, h=10, y=6;
    group.add(makeWall(s, t, t, 0, y, -s/2)); group.add(makeWall(s, t, t, 0, y, s/2));
    group.add(makeWall(t, t, s, -s/2, y, 0)); group.add(makeWall(t, t, s, s/2, y, 0));
    group.add(makeWall(t, h, t, -s/2, y, -s/2)); group.add(makeWall(t, h, t, s/2, y, -s/2));
    group.add(makeWall(t, h, t, -s/2, y, s/2));  group.add(makeWall(t, h, t, s/2, y, s/2));
  }
];
let levelIndex = 0;
const levelGroup = new THREE.Group(); scene.add(levelGroup);

function loadLevel(i){
  levelGroup.clear();
  // dispose old children geometries/materials if any
  for(const c of [...scene.children]){} // (materials are reused, fine for proto)
  // rebuild
  levels[i](levelGroup);
  ball.position.set(0, ballRadius, -ARENA.z + 4);
  vel.set(0,0,0);
  squash = 0;
  controls.target.copy(ball.position);
  document.getElementById('levelName').textContent = (i+1);
}
loadLevel(levelIndex);

/* ---------- UI ---------- */
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const resetBtn = document.getElementById('resetBtn');
prevBtn.onclick = ()=>{ levelIndex = (levelIndex+levels.length-1)%levels.length; loadLevel(levelIndex); };
nextBtn.onclick = ()=>{ levelIndex = (levelIndex+1)%levels.length; loadLevel(levelIndex); };
resetBtn.onclick = ()=> loadLevel(levelIndex);

/* ---------- helpers ---------- */
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

/* ---------- main loop ---------- */
let last = performance.now();
let trailTimer = 0;

function tick(now){
  const dt = Math.min(0.033, (now-last)/1000); last = now;

  // input -> acceleration
  const dir = new THREE.Vector3(
    (keys.has('ArrowRight')?1:0) + (keys.has('ArrowLeft')?-1:0),
    (keys.has(' ')?1:0) + (keys.has('Shift')?-1:0),
    (keys.has('ArrowDown')?1:0) + (keys.has('ArrowUp')?-1:0) // +z = back, -z = forward
  ).normalize();

  // accelerate in world axes
  if(dir.lengthSq()>0){
    vel.x += dir.x * accel * dt;
    vel.y += dir.y * accel * dt;
    vel.z += dir.z * accel * dt;
  }

  // limit speed & apply drag
  if(vel.length()>maxSpeed) vel.setLength(maxSpeed);
  vel.multiplyScalar(Math.pow(drag, dt*60));

  // integrate
  ball.position.addScaledVector(vel, dt);

  // collisions with arena bounds (simple AABB)
  // X
  let hit = false;
  if(ball.position.x > ARENA.x - ballRadius){ ball.position.x = ARENA.x - ballRadius; vel.x *= -bounce; hit = true; }
  if(ball.position.x < -ARENA.x + ballRadius){ ball.position.x = -ARENA.x + ballRadius; vel.x *= -bounce; hit = true; }
  // Y
  if(ball.position.y > ARENA.y - ballRadius){ ball.position.y = ARENA.y - ballRadius; vel.y *= -bounce; hit = true; }
  if(ball.position.y < ballRadius){ ball.position.y = ballRadius; vel.y *= -bounce; hit = true; }
  // Z
  if(ball.position.z > ARENA.z - ballRadius){ ball.position.z = ARENA.z - ballRadius; vel.z *= -bounce; hit = true; }
  if(ball.position.z < -ARENA.z + ballRadius){ ball.position.z = -ARENA.z + ballRadius; vel.z *= -bounce; hit = true; }

  // squash & stretch on impact
  if(hit){ squash = 0.18; }

  // animate squash
  if(squash>0){
    const s = 1 + Math.sin((0.5 - Math.abs(0.5 - squash)/0.18)*Math.PI)*0.2;
    // stretch along velocity direction
    const v = vel.clone(); const speed = v.length();
    if(speed>0.001){ v.normalize(); }
    const sx = 1 + (speed>0.001 ? v.x*0.15 : 0);
    const sy = 1 + (speed>0.001 ? v.y*0.15 : 0);
    const sz = 1 + (speed>0.001 ? v.z*0.15 : 0);
    ball.scale.set(s*sx, s*sy, s*sz);
    squash -= dt;
    if(squash<=0) ball.scale.set(1,1,1);
  }

  // simplistic wall collisions with internal obstacles
  // (use bounding boxes; for prototype, boxes are axis-aligned)
  levelGroup.children.forEach(w=>{
    if(w.geometry.boundingBox==null) w.geometry.computeBoundingBox();
    const bb = w.geometry.boundingBox.clone();
    bb.min.add(w.position); bb.max.add(w.position);
    const p = ball.position.clone();
    const closest = new THREE.Vector3(
      clamp(p.x, bb.min.x+ballRadius, bb.max.x-ballRadius),
      clamp(p.y, bb.min.y+ballRadius, bb.max.y-ballRadius),
      clamp(p.z, bb.min.z+ballRadius, bb.max.z-ballRadius)
    );
    if(Math.abs(p.x-closest.x)<1e-6 && Math.abs(p.y-closest.y)<1e-6 && Math.abs(p.z-closest.z)<1e-6){
      // outside box — no collision
    }else{
      // push out along deepest axis
      const pen = new THREE.Vector3(
        (p.x<closest.x)? (closest.x-p.x) : (closest.x-p.x),
        (p.y<closest.y)? (closest.y-p.y) : (closest.y-p.y),
        (p.z<closest.z)? (closest.z-p.z) : (closest.z-p.z)
      );
      // find axis with largest penetration amount
      const ax = Math.abs(pen.x), ay = Math.abs(pen.y), az = Math.abs(pen.z);
      if(ax>=ay && ax>=az){ ball.position.x = closest.x; vel.x *= -bounce; }
      else if(ay>=ax && ay>=az){ ball.position.y = closest.y; vel.y *= -bounce; }
      else { ball.position.z = closest.z; vel.z *= -bounce; }
      squash = 0.18;
    }
  });

  // leave a glow trail
  trailTimer += dt;
  if(trailTimer > 0.035){
    trailTimer = 0;
    spawnTrail();
  }
  for(let i=trailPool.length-1; i>=0; i--){
    const s = trailPool[i];
    s.userData.life -= dt;
    s.material.opacity = Math.max(0, s.userData.life / 0.9);
    s.position.y += s.userData.velY * dt; // tiny drift
    if(s.userData.life <= 0){
      s.parent.remove(s);
      trailPool.splice(i,1);
      s.material.map.dispose(); // lightweight cleanup (ok to omit)
      s.material.dispose();
      // (sprite geom is internal; safe to let GC handle)
    }
  }

  // camera follow
  controls.target.lerp(ball.position, 0.12);
  controls.update();

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* ---------- resize ---------- */
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>

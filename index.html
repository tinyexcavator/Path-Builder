<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Roller Glow — Safari Deep Debug</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'/>">
<style>
  html,body{margin:0;height:100%;background:#0b0f14;color:#e8f0ff;font-family:system-ui}
  #gl{display:block;width:100vw;height:100vh}
  #ui{position:fixed;left:12px;right:12px;top:12px;display:flex;justify-content:space-between;gap:8px;z-index:5;pointer-events:none}
  .card{pointer-events:auto;background:rgba(16,22,30,.72);border:1px solid #203040;border-radius:12px;padding:8px 10px;backdrop-filter:blur(6px)}
  .btn{cursor:pointer;border:1px solid #2f445c;border-radius:10px;background:linear-gradient(180deg,#1a2430,#121923);color:#eaf4ff;font-weight:700;padding:8px 12px}
  .hint{opacity:.85;font-size:12px}
  #hud{
    position:fixed;left:12px;bottom:12px;z-index:6;
    background:rgba(0,0,0,.45);border:1px solid #203040;border-radius:10px;
    padding:8px 10px;font:12px/1.3 ui-monospace,Menlo,Consolas,monospace;white-space:pre
  }
  kbd{border:1px solid #2f445c;border-radius:6px;padding:0 6px;background:#0f1620}
</style>
</head>
<body>
<div id="ui">
  <div class="card">
    <button id="prevBtn" class="btn">Prev</button>
    <span>LEVEL <span id="levelName">1</span> / 5</span>
    <button id="nextBtn" class="btn">Next</button>
    <button id="resetBtn" class="btn">Reset</button>
  </div>
  <div class="card hint">
    Mouse drag = rotate • Wheel = zoom • Arrows = slide • Space = up • Shift = down
  </div>
</div>
<div id="hud"></div>
<canvas id="gl"></canvas>

<script>
/* ================= Canvas & GL ================= */
const canvas=document.getElementById('gl');
const gl=canvas.getContext('webgl',{alpha:false,antialias:true});
if(!gl){ alert('WebGL not available'); throw new Error('No WebGL'); }
const hud=document.getElementById('hud');

function fitCanvas(){
  const dpr = Math.min(2, window.devicePixelRatio||1);
  const cw = Math.max(1, canvas.clientWidth|0);
  const ch = Math.max(1, canvas.clientHeight|0);
  const w = Math.floor(cw*dpr), h = Math.floor(ch*dpr);
  if(canvas.width!==w || canvas.height!==h){
    canvas.width = w; canvas.height = h; gl.viewport(0,0,w,h);
  }
}
fitCanvas(); addEventListener('resize', fitCanvas); new ResizeObserver(fitCanvas).observe(canvas);

/* ================= Math ================= */
const M=Float32Array;
function mat4(){return new M(16)}
function I(){return new M([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1])}
function mul(a,b,out){out=out||mat4();const o=out,A=a,B=b;
  for(let r=0;r<4;r++)for(let c=0;c<4;c++)o[c+4*r]=A[0+4*r]*B[c+0]+A[1+4*r]*B[c+4]+A[2+4*r]*B[c+8]+A[3+4*r]*B[c+12];
  return o}
function T(v){const t=I();t[12]=v[0];t[13]=v[1];t[14]=v[2];return t}
function S(v){const s=I();s[0]=v[0];s[5]=v[1];s[10]=v[2];return s}
function compose(...ms){return ms.reduce((acc,m)=>mul(m,acc), I());}
function perspective(fovy,aspect,near,far){const f=1/Math.tan(fovy/2), nf=1/(near-far);const o=mat4();
  o[0]=f/aspect;o[5]=f;o[10]=(far+near)*nf;o[11]=-1;o[14]=2*far*near*nf;return o}
function lookAt(eye,at,up){
  const sub=(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]];
  const cross=(a,b)=>[a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
  const len=a=>Math.hypot(a[0],a[1],a[2]), norm=a=>{const l=len(a)||1;return[a[0]/l,a[1]/l,a[2]/l]};
  const z=norm(sub(eye,at)), x=norm(cross(up,z)), y=cross(z,x); const o=I();
  o[0]=x[0]; o[1]=y[0]; o[2]=z[0];
  o[4]=x[1]; o[5]=y[1]; o[6]=z[1];
  o[8]=x[2]; o[9]=y[2]; o[10]=z[2];
  o[12]=-(x[0]*eye[0]+x[1]*eye[1]+x[2]*eye[2]);
  o[13]=-(y[0]*eye[0]+y[1]*eye[1]+y[2]*eye[2]);
  o[14]=-(z[0]*eye[0]+z[1]*eye[1]+z[2]*eye[2]);
  return o;
}
function normalMat3FromMat4(m){
  const a00=m[0], a01=m[1], a02=m[2];
  const a10=m[4], a11=m[5], a12=m[6];
  const a20=m[8], a21=m[9], a22=m[10];
  const b01 =  a22*a11 - a12*a21;
  const b11 = -a22*a10 + a12*a20;
  const b21 =  a21*a10 - a11*a20;
  let det = a00*b01 + a01*b11 + a02*b21;
  if (!det) return new Float32Array([1,0,0, 0,1,0, 0,0,1]);
  det = 1.0/det;
  const n = new Float32Array(9);
  n[0]=b01*det; n[1]=(-a22*a01 + a02*a21)*det; n[2]=( a12*a01 - a02*a11)*det;
  n[3]=b11*det; n[4]=( a22*a00 - a02*a20)*det; n[5]=(-a12*a00 + a02*a10)*det;
  n[6]=b21*det; n[7]=(-a21*a00 + a01*a20)*det; n[8]=( a11*a00 - a01*a10)*det;
  return n;
}

/* ================= Shaders ================= */
const VERT=`
attribute vec3 aPos,aNormal;
uniform mat4 uM,uVP;
uniform mat3 uN;
uniform vec3 uColor;
varying vec3 vN,vColor;
void main(){
  gl_Position = uVP * uM * vec4(aPos,1.0);
  vN = uN * aNormal;
  vColor = uColor;
}`;
const FRAG=`
precision mediump float;
varying vec3 vN,vColor;
uniform vec3 uLightDir;
uniform float uAlpha;
void main(){
  float NdL = max(dot(normalize(vN), normalize(-uLightDir)), 0.08);
  vec3 rgb = vColor * (0.25 + 0.75*NdL);
  gl_FragColor = vec4(rgb, uAlpha);
}`;
function compile(type,src){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));return s}
const prog=gl.createProgram();
gl.attachShader(prog,compile(gl.VERTEX_SHADER,VERT));
gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,FRAG));
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
  console.error('Program link error:', gl.getProgramInfoLog(prog));
}
gl.useProgram(prog);
const loc={
  aPos:gl.getAttribLocation(prog,'aPos'),
  aNormal:gl.getAttribLocation(prog,'aNormal'),
  uM:gl.getUniformLocation(prog,'uM'),
  uVP:gl.getUniformLocation(prog,'uVP'),
  uN:gl.getUniformLocation(prog,'uN'),
  uColor:gl.getUniformLocation(prog,'uColor'),
  uLightDir:gl.getUniformLocation(prog,'uLightDir'),
  uAlpha:gl.getUniformLocation(prog,'uAlpha'),
};
gl.uniform3fv(loc.uLightDir, new Float32Array([0.4,1.0,0.6]));
gl.clearColor(0.06,0.08,0.12,1);

/* ================= Geometry ================= */
function makeBox(w,h,d){
  const x=w/2,y=h/2,z=d/2,P=[],N=[],faces=[
    [[ x,-y,-z],[ x, y,-z],[ x, y, z],[ x,-y, z]],[[-x,-y,-z],[-x,-y, z],[-x, y, z],[-x, y,-z]],
    [[-x, y,-z],[-x, y, z],[ x, y, z],[ x, y,-z]],[[-x,-y,-z],[ x,-y,-z],[ x,-y, z],[-x,-y, z]],
    [[-x,-y, z],[ x,-y, z],[ x, y, z],[-x, y, z]],[[-x,-y,-z],[-x, y,-z],[ x, y,-z],[ x,-y,-z]]
  ], norms=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];
  for(let f=0;f<6;f++){const v=faces[f],n=norms[f],tris=[v[0],v[1],v[2], v[0],v[2],v[3]];
    tris.forEach(t=>{P.push(...t);N.push(...n);});}
  return {pos:new Float32Array(P), nor:new Float32Array(N), count:P.length/3};
}
function makeSphere(r, seg=28, rings=18){
  const pos=[],nor=[];
  const sph=(t,p)=>[Math.cos(t)*Math.cos(p), Math.sin(p), Math.sin(t)*Math.cos(p)];
  const tri=(a,b,c)=>{[a,b,c].forEach(v=>{pos.push(r*v[0],r*v[1],r*v[2]); nor.push(v[0],v[1],v[2]);});};
  for(let j=0;j<rings;j++){const p1=(j/rings-0.5)*Math.PI,p2=((j+1)/rings-0.5)*Math.PI;
    for(let i=0;i<seg;i++){const t1=i/seg*2*Math.PI,t2=(i+1)/seg*2*Math.PI; const q=[sph(t1,p1),sph(t2,p1),sph(t2,p2),sph(t1,p2)];
      tri(q[0],q[1],q[2]); tri(q[0],q[2],q[3]);}}
  return {pos:new Float32Array(pos), nor:new Float32Array(nor), count:pos.length/3};
}
function makeVAO(geo){
  const inter=new Float32Array(geo.pos.length+geo.nor.length);
  for(let i=0,j=0;i<geo.pos.length/3;i++,j+=6){
    inter[j]=geo.pos[i*3]; inter[j+1]=geo.pos[i*3+1]; inter[j+2]=geo.pos[i*3+2];
    inter[j+3]=geo.nor[i*3]; inter[j+4]=geo.nor[i*3+1]; inter[j+5]=geo.nor[i*3+2];
  }
  const buf=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.bufferData(gl.ARRAY_BUFFER,inter,gl.STATIC_DRAW);
  const stride=24;
  if (loc.aPos >= 0) { gl.vertexAttribPointer(loc.aPos,3,gl.FLOAT,false,stride,0); gl.enableVertexAttribArray(loc.aPos); }
  if (loc.aNormal >= 0) { gl.vertexAttribPointer(loc.aNormal,3,gl.FLOAT,false,stride,12); gl.enableVertexAttribArray(loc.aNormal); }
  return {buf, count:geo.count};
}
const boxVAO=makeVAO(makeBox(1,1,1));
const sphereVAO=makeVAO(makeSphere(1));

/* ================= Scene Data ================= */
gl.enable(gl.DEPTH_TEST);
let ENABLE_CULL=false;  // toggled by C
let ENABLE_BLEND=true;  // toggled by B
function syncCull(){
  if(ENABLE_CULL){ gl.frontFace(gl.CCW); gl.enable(gl.CULL_FACE); gl.cullFace(gl.BACK); }
  else { gl.disable(gl.CULL_FACE); }
}
syncCull();

const ARENA={x:24,y:14,z:36};
let walls=[]; const W=(w,h,d,x,y,z)=>walls.push({w,h,d,x,y,z});
function buildLevel(i){
  walls=[];
  W(ARENA.x*2,10,0.8, 0,4.5,-ARENA.z+0.4);
  W(ARENA.x*2,10,0.8, 0,4.5, ARENA.z-0.4);
  W(0.8,10,ARENA.z*2,-ARENA.x+0.4,4.5,0);
  W(0.8,10,ARENA.z*2, ARENA.x-0.4,4.5,0);
  const L=[
    ()=>{ W(8,2,2,-10,2,-12); W(8,2,2,10,2,-6); W(8,2,2,0,2,2); W(8,2,2,-10,6,10); W(8,2,2,10,8,14); W(2,8,10,0,4,-18); },
    ()=>{ W(18,2,0.8,0,3,-12); W(18,2,0.8,0,7,-6); W(18,2,0.8,0,3,6); W(18,2,0.8,0,7,12); W(0.8,8,12,-8,4,0); W(0.8,8,12,8,4,0); },
    ()=>{ W(10,2,2,-8,8,-12); W(10,2,2,8,10,-4); W(10,2,2,0,7,10); W(2,8,8,0,4,0); },
    ()=>{ for(let z=-12;z<=12;z+=6){ W(18,2,0.6,0,3,z); W(18,2,0.6,0,7,z+3);} W(0.6,8,18,-6,4,0); W(0.6,8,18,6,4,0); },
    ()=>{ const s=10,t=0.8,h=10,y=6; W(s,t,t,0,y,-s/2); W(s,t,t,0,y,s/2); W(t,t,s,-s/2,y,0); W(t,t,s,s/2,y,0);
          W(t,h,t,-s/2,y,-s/2); W(t,h,t,s/2,y,-s/2); W(t,h,t,-s/2,y,s/2); W(t,h,t,s/2,y,s/2); }
  ];
  L[i]();
}
let level=0; buildLevel(level); document.getElementById('levelName').textContent=level+1;

/* ball + camera */
const radius=1.2; let ballPos=[0,radius,-ARENA.z+4];
function resetBall(){ ballPos=[0,radius,-ARENA.z+4]; sliding=false; }
let camDist=34, theta=0.9, phi=0.9, dragging=false, lx=0,ly=0;
let FIXED_CAM=false;     // toggled by F
let IDENTITY_VP=false;   // toggled by V
canvas.addEventListener('mousedown',e=>{dragging=true; lx=e.clientX; ly=e.clientY;});
addEventListener('mouseup',()=>dragging=false);
addEventListener('mousemove',e=>{ if(!dragging) return; const dx=(e.clientX-lx)/canvas.clientWidth, dy=(e.clientY-ly)/canvas.clientHeight; lx=e.clientX; ly=e.clientY; theta-=dx*3; phi-=dy*3; phi=Math.max(0.2, Math.min(2.7, phi)); });
canvas.addEventListener('wheel',(e)=>{ e.preventDefault(); camDist *= (1 + Math.sign(e.deltaY)*0.08); camDist=Math.max(10,Math.min(90,camDist)); },{passive:false});

/* slide */
let sliding=false, slideDir=[0,0,0], slideTarget=[0,0,0];
const keyDir={ArrowLeft:[-1,0,0],ArrowRight:[1,0,0],ArrowUp:[0,0,-1],ArrowDown:[0,0,1],' ':[0,1,0],Shift:[0,-1,0]};
addEventListener('keydown',e=>{
  const k=(e.key===' ')?' ':(e.key.startsWith('Shift')?'Shift':e.key);
  if(k==='d' || k==='D'){ DEBUG_TRIANGLE=!DEBUG_TRIANGLE; console.log('DEBUG_TRIANGLE',DEBUG_TRIANGLE); return; }
  if(k==='u' || k==='U'){ UNIT_CUBE=!UNIT_CUBE; console.log('UNIT_CUBE',UNIT_CUBE); return; }
  if(k==='c' || k==='C'){ ENABLE_CULL=!ENABLE_CULL; syncCull(); return; }
  if(k==='b' || k==='B'){ ENABLE_BLEND=!ENABLE_BLEND; return; }
  if(k==='v' || k==='V'){ IDENTITY_VP=!IDENTITY_VP; return; }
  if(k==='f' || k==='F'){ FIXED_CAM=!FIXED_CAM; return; }
  if(k==='g' || k==='G'){ console.log('gl.getError() =', gl.getError()); return; }

  const d=keyDir[k]; if(!d) return; e.preventDefault();
  if(sliding) return;
  const max=distanceToHit(ballPos,d,radius);
  if(max<=1e-4) return;
  slideDir=[...d]; slideTarget=[ballPos[0]+d[0]*max,ballPos[1]+d[1]*max,ballPos[2]+d[2]*max]; sliding=true;
});
function distanceToHit(p,d,r){
  let dist=Infinity;
  if(d[0]>0) dist=Math.min(dist,(ARENA.x-r-p[0])); if(d[0]<0) dist=Math.min(dist,(p[0]-(-ARENA.x+r)));
  if(d[1]>0) dist=Math.min(dist,(ARENA.y-r-p[1])); if(d[1]<0) dist=Math.min(dist,(p[1]-r));
  if(d[2]>0) dist=Math.min(dist,(ARENA.z-r-p[2])); if(d[2]<0) dist=Math.min(dist,(p[2]-(-ARENA.z+r)));
  for(const w of walls){
    const min=[w.x-w.w/2,w.y-w.h/2,w.z-w.d/2], max=[w.x+w.w/2,w.y+w.h/2,w.z+w.d/2];
    const ov=(p[1]+r>min[1]&&p[1]-r<max[1])&&(p[0]+r>min[0]&&p[0]-r<max[0])&&(p[2]+r>min[2]&&p[2]-r<max[2]);
    if(!ov) continue;
    if(d[0]>0 && p[0]<min[0]-r) dist=Math.min(dist,(min[0]-r)-p[0]);
    if(d[0]<0 && p[0]>max[0]+r) dist=Math.min(dist,p[0]-(max[0]+r));
    if(d[1]>0 && p[1]<min[1]-r) dist=Math.min(dist,(min[1]-r)-p[1]);
    if(d[1]<0 && p[1]>max[1]+r) dist=Math.min(dist,p[1]-(max[1]+r));
    if(d[2]>0 && p[2]<min[2]-r) dist=Math.min(dist,(min[2]-r)-p[2]);
    if(d[2]<0 && p[2]>max[2]+r) dist=Math.min(dist,p[2]-(max[2]+r));
  }
  return Math.max(0, dist===Infinity?0:dist);
}

/* UI buttons */
document.getElementById('prevBtn').onclick=()=>{ level=(level+4)%5; buildLevel(level); resetBall(); document.getElementById('levelName').textContent=level+1; };
document.getElementById('nextBtn').onclick=()=>{ level=(level+1)%5; buildLevel(level); resetBall(); document.getElementById('levelName').textContent=level+1; };
document.getElementById('resetBtn').onclick=()=> resetBall();

/* ============ Draw helpers + debug ============ */
function bindVAO(vao){
  gl.bindBuffer(gl.ARRAY_BUFFER, vao.buf);
  if (loc.aPos >= 0) {
    gl.vertexAttribPointer(loc.aPos, 3, gl.FLOAT, false, 24, 0);
    gl.enableVertexAttribArray(loc.aPos);
  }
  if (loc.aNormal >= 0) {
    gl.vertexAttribPointer(loc.aNormal, 3, gl.FLOAT, false, 24, 12);
    gl.enableVertexAttribArray(loc.aNormal);
  }
}
function draw(vao, model, color, alpha){
  gl.useProgram(prog);
  bindVAO(vao); 
  gl.uniform3fv(loc.uColor, new Float32Array(color));
  gl.uniform1f(loc.uAlpha, alpha);
  gl.uniformMatrix4fv(loc.uM, false, model);
  gl.uniformMatrix3fv(loc.uN, false, normalMat3FromMat4(model));
  gl.bindBuffer(gl.ARRAY_BUFFER, vao.buf);
  gl.drawArrays(gl.TRIANGLES, 0, vao.count);
}
let DEBUG_TRIANGLE=false;
let UNIT_CUBE=false;

const dbgBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, dbgBuf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1,-1,0,  3,-1,0,  -1,3,0 ]), gl.STATIC_DRAW);
function debugTriangleDraw(){
  gl.useProgram(prog);
  if (loc.aPos >= 0) {
    gl.bindBuffer(gl.ARRAY_BUFFER, dbgBuf);
    gl.vertexAttribPointer(loc.aPos,3,gl.FLOAT,false,0,0);
    gl.enableVertexAttribArray(loc.aPos);
  }
  gl.disable(gl.BLEND); gl.disable(gl.CULL_FACE);
  gl.uniform3fv(loc.uColor, new Float32Array([1,0,0]));
  gl.uniform1f(loc.uAlpha, 1.0);
  const I4 = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
  const I3 = new Float32Array([1,0,0, 0,1,0, 0,0,1]);
  gl.uniformMatrix4fv(loc.uVP,false,I4);
  gl.uniformMatrix4fv(loc.uM,false,I4);
  gl.uniformMatrix3fv(loc.uN,false,I3);
  gl.drawArrays(gl.TRIANGLES,0,3);
}

/* ============ Main loop ============ */
let last=performance.now(), frames=0, fps=0, lastFPS=performance.now();
function frame(now){
  fitCanvas();

  // Blink clear color each second (proves frame loop works)
  const t = (performance.now()/1000)|0;
  gl.clearColor((t%2)?0.2:0.06, 0.08, 0.12, 1);
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

  // Optional motion
  const dt=Math.min(0.033,(now-last)/1000); last=now;
  if(sliding){
    const speed=28, step=speed*dt;
    const dx=slideTarget[0]-ballPos[0], dy=slideTarget[1]-ballPos[1], dz=slideTarget[2]-ballPos[2];
    const dist=Math.hypot(dx,dy,dz);
    if(dist<=step){ ballPos=[...slideTarget]; sliding=false; }
    else { ballPos=[ballPos[0]+slideDir[0]*step, ballPos[1]+slideDir[1]*step, ballPos[2]+slideDir[2]*step]; }
  }

  // Modes
  if(DEBUG_TRIANGLE){
    debugTriangleDraw();
  } else {
    // Build VP
    let VP;
    if(IDENTITY_VP){
      VP = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
    }else{
      const aspect = (canvas.width||1)/(canvas.height||1);
      const P=perspective(60*Math.PI/180, aspect, 0.1, 1000);
      const dist = camDist;
      const eye = FIXED_CAM
        ? [0,50,50]
        : [ ballPos[0]+dist*Math.sin(phi)*Math.cos(theta),
            ballPos[1]+dist*Math.cos(phi),
            ballPos[2]+dist*Math.sin(phi)*Math.sin(theta) ];
      const V=lookAt(eye, ballPos, [0,1,0]);
      VP=mul(P,V,mat4());
    }
    gl.uniformMatrix4fv(loc.uVP, false, VP);

    // Scene
    if(ENABLE_BLEND) gl.enable(gl.BLEND); else gl.disable(gl.BLEND);
    syncCull();

    // floor
    draw(boxVAO, compose(T([0,-0.5,0]), S([ARENA.x*2,1,ARENA.z*2])), [0.08,0.12,0.18], 1.0);

    // glass walls
    if(ENABLE_BLEND) gl.enable(gl.BLEND);
    for(const w of walls){
      draw(boxVAO, compose(T([w.x,w.y,w.z]), S([w.w,w.h,w.d])), [0.55,0.71,1.0], 0.35);
    }
    if(ENABLE_BLEND) gl.disable(gl.BLEND);

    // ball
    draw(sphereVAO, compose(T(ballPos), S([radius,radius,radius])), [0.27,0.64,1.0], 1.0);

    // UNIT_CUBE overlay test (identity VP assumed)
    if(UNIT_CUBE){
      const VPid = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
      gl.uniformMatrix4fv(loc.uVP,false,VPid);
      gl.disable(gl.CULL_FACE); gl.disable(gl.BLEND);
      draw(boxVAO, compose(T([0,0,0]), S([0.5,0.5,0.5])), [0,1,0], 1.0);
    }
  }

  // FPS
  frames++; if (now - lastFPS > 1000) { fps = frames; frames = 0; lastFPS = now; }

  // HUD
  hud.textContent =
`FPS: ${fps}
Mode: ${DEBUG_TRIANGLE?'DEBUG_TRIANGLE':(UNIT_CUBE?'UNIT_CUBE':(IDENTITY_VP?'IDENTITY_VP':'NORMAL'))}
Cull: ${ENABLE_CULL}  Blend: ${ENABLE_BLEND}
Client: ${canvas.clientWidth}×${canvas.clientHeight}
Backing: ${canvas.width}×${canvas.height}  DPR: ${window.devicePixelRatio||1}
camDist: ${camDist.toFixed(2)}  theta: ${theta.toFixed(2)}  phi: ${phi.toFixed(2)}
Keys: <D> triangle  <U> unit-cube  <V> identity-VP
      <C> cull  <B> blend  <F> fixed-cam  <G> gl.getError()`;

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>

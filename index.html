<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Roller Glow — Slide Prototype</title>
<style>
  html,body{height:100%;margin:0;background:#0b0f14;color:#e8f0ff;font-family:system-ui,-apple-system,Segoe UI,Roboto}
  #ui{position:fixed;left:12px;right:12px;top:12px;display:flex;gap:8px;justify-content:space-between;align-items:center;pointer-events:none;z-index:5}
  .card{pointer-events:auto;background:rgba(16,22,30,.72);backdrop-filter:blur(6px);border:1px solid #203040;border-radius:12px;padding:8px 10px;box-shadow:0 6px 24px rgba(0,0,0,.35)}
  .btn{cursor:pointer;border:1px solid #2f445c;border-radius:10px;background:linear-gradient(180deg,#1a2430,#121923);color:#eaf4ff;font-weight:700;padding:8px 12px}
  .hint{opacity:.85;font-size:12px}
  canvas{display:block}
</style>
</head>
<body>
<div id="ui">
  <div class="card">
    <button id="prevBtn" class="btn">Prev</button>
    <span>LEVEL <span id="levelName">1</span> / 5</span>
    <button id="nextBtn" class="btn">Next</button>
    <button id="resetBtn" class="btn">Reset</button>
  </div>
  <div class="card hint">Mouse drag = rotate • Wheel = zoom • Arrows = slide • Space = up • Shift = down</div>
</div>

<script type="module">
/* Import Three.js + OrbitControls from CDN */
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js?v=4';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js?v=4';

/* ---------- Scene / Camera / Renderer ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0f14);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(22, 18, 28);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

/* ---------- Controls ---------- */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance = 8;
controls.maxDistance = 80;

/* ---------- Lights ---------- */
scene.add(new THREE.AmbientLight(0x99aabb, 0.7));
const key = new THREE.DirectionalLight(0xffffff, 0.9);
key.position.set(10,20,10); key.castShadow = true; key.shadow.mapSize.set(1024,1024);
scene.add(key);
const rim = new THREE.DirectionalLight(0x66aaff, 0.35);
rim.position.set(-12,12,-8); scene.add(rim);

/* ---------- Materials ---------- */
const glass = new THREE.MeshPhysicalMaterial({
  color: 0x8fb6ff, metalness: 0.2, roughness: 0.15,
  transmission: 0.6, transparent: true, opacity: 0.35, thickness: 0.6, ior: 1.25
});
const floorMat = new THREE.MeshPhongMaterial({ color: 0x14202e, shininess: 8 });

/* ---------- Arena ---------- */
const ARENA = { x: 24, y: 14, z: 36 }; // half-extents
const floor = new THREE.Mesh(new THREE.BoxGeometry(ARENA.x*2, 1, ARENA.z*2), floorMat);
floor.position.y = -0.5; floor.receiveShadow = true; scene.add(floor);

/* nice looking perimeter “glass box” so the bounds are visible */
const border = new THREE.Group(); scene.add(border);
function borderWalls(){
  const t=0.8, h=10;
  const w1 = new THREE.Mesh(new THREE.BoxGeometry(ARENA.x*2, h, t), glass); w1.position.set(0, h/2-1, -ARENA.z+t/2);
  const w2 = w1.clone(); w2.position.z = ARENA.z-t/2;
  const w3 = new THREE.Mesh(new THREE.BoxGeometry(t, h, ARENA.z*2), glass); w3.position.set(-ARENA.x+t/2, h/2-1, 0);
  const w4 = w3.clone(); w4.position.x = ARENA.x-t/2;
  border.add(w1,w2,w3,w4);
}
borderWalls();

/* ---------- Player Ball ---------- */
const ballRadius = 1.2;
const ball = new THREE.Mesh(
  new THREE.SphereGeometry(ballRadius, 48, 32),
  new THREE.MeshPhysicalMaterial({ color: 0x45a3ff, metalness: 1, roughness: 0.15, clearcoat: 1, clearcoatRoughness: 0.06 })
);
ball.position.set(0, ballRadius, -ARENA.z + 4);
ball.castShadow = true; scene.add(ball);
ball.add(new THREE.PointLight(0x46c0ff, 0.9, 12));
controls.target.copy(ball.position);

/* ---------- Trail ---------- */
const trailTex = (()=>{ const s=128,c=document.createElement('canvas'); c.width=c.height=s;
  const g=c.getContext('2d'),r=s/2,gr=g.createRadialGradient(r,r,0,r,r,r);
  gr.addColorStop(0,'rgba(120,220,255,0.9)'); gr.addColorStop(0.5,'rgba(80,180,255,0.35)'); gr.addColorStop(1,'rgba(0,0,0,0)');
  g.fillStyle=gr; g.fillRect(0,0,s,s);
  const t=new THREE.CanvasTexture(c); t.minFilter=THREE.LinearFilter; return t; })();
const trailGroup = new THREE.Group(); scene.add(trailGroup);
const trailPool = [];
function spawnTrail(){
  const s=0.9+Math.random()*0.5;
  const spr=new THREE.Sprite(new THREE.SpriteMaterial({map:trailTex,transparent:true,depthWrite:false}));
  spr.scale.setScalar(s); spr.position.copy(ball.position); spr.position.y -= (ballRadius-0.2);
  spr.userData.life=0.9; trailGroup.add(spr); trailPool.push(spr);
}

/* ---------- Level Building ---------- */
const levelGroup = new THREE.Group(); scene.add(levelGroup);
function addBox(w,h,d,x,y,z){ const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d), glass); m.position.set(x,y,z); m.castShadow=m.receiveShadow=true; m.geometry.computeBoundingBox(); levelGroup.add(m); return m; }

const makeLevels = [
  // 1) Intro lanes
  ()=>{
    addBox(8,2,2, -10,2,-12);
    addBox(8,2,2,  10,2,-6);
    addBox(8,2,2,  0,2, 2);
    addBox(8,2,2, -10,6,10);
    addBox(8,2,2,  10,8,14);
    addBox(2,8,10, 0,4, -18);  // vertical blocker
  },
  // 2) Two-story corridors
  ()=>{
    addBox(18,2,0.8, 0,3,-12);
    addBox(18,2,0.8, 0,7, -6);
    addBox(18,2,0.8, 0,3,  6);
    addBox(18,2,0.8, 0,7,  12);
    addBox(0.8,8,12, -8,4, 0);
    addBox(0.8,8,12,  8,4, 0);
  },
  // 3) Floating bridges
  ()=>{
    addBox(10,2,2, -8,8,-12);
    addBox(10,2,2,  8,10,-4);
    addBox(10,2,2,  0,7, 10);
    addBox(2,8,8,  0,4, 0);
  },
  // 4) Glass labyrinth grid
  ()=>{
    for(let z=-12; z<=12; z+=6){
      addBox(18,2,0.6, 0, 3, z);
      addBox(18,2,0.6, 0, 7, z+3);
    }
    addBox(0.6,8,18, -6,4, 0);
    addBox(0.6,8,18,  6,4, 0);
    addBox(8,2,2, -12,2,-16);
    addBox(8,2,2,  12,2, 16);
  },
  // 5) Hollow cube core
  ()=>{
    const s=10,t=0.8,h=10,y=6;
    addBox(s, t, t, 0, y, -s/2); addBox(s, t, t, 0, y,  s/2);
    addBox(t, t, s, -s/2, y, 0); addBox(t, t, s,  s/2, y, 0);
    addBox(t, h, t, -s/2, y, -s/2); addBox(t, h, t,  s/2, y, -s/2);
    addBox(t, h, t, -s/2, y,  s/2); addBox(t, h, t,  s/2, y,  s/2);
  }
];

let levelIndex = 0;
const levelNameEl = document.getElementById('levelName');

function clearLevel(){ for(const c of [...levelGroup.children]){ levelGroup.remove(c); c.geometry.dispose(); } }

function loadLevel(i){
  clearLevel();
  makeLevels[i]();
  resetBall();
  levelNameEl.textContent = (i+1);
}
function resetBall(){
  ball.position.set(0, ballRadius, -ARENA.z + 4);
  vel.set(0,0,0);
  sliding=false; slideDir.set(0,0,0);
  controls.target.copy(ball.position);
}
loadLevel(levelIndex);

/* ---------- Input: one-tap sliding ---------- */
const keysToDir = {
  ArrowLeft:  new THREE.Vector3(-1, 0,  0),
  ArrowRight: new THREE.Vector3( 1, 0,  0),
  ArrowUp:    new THREE.Vector3( 0, 0, -1),
  ArrowDown:  new THREE.Vector3( 0, 0,  1),
  ' ':        new THREE.Vector3( 0, 1,  0),   // Space
  Shift:      new THREE.Vector3( 0,-1,  0)
};
addEventListener('keydown', (e)=>{
  const k = (e.key === ' ') ? ' ' : (e.key.startsWith('Shift')?'Shift':e.key);
  if(!keysToDir[k]) return;
  e.preventDefault();
  if(sliding) return; // ignore while moving
  startSlide(keysToDir[k].clone());
});

/* ---------- Slide-to-collision system ---------- */
const slideSpeed = 28; // units/sec
let sliding = false;
let slideDir = new THREE.Vector3();
let slideTarget = new THREE.Vector3();
let squash = 0;
let vel = new THREE.Vector3();

function startSlide(dir){
  // compute distance to nearest obstacle/bounds in that direction, then set target
  const maxDist = distanceToHit(ball.position, dir, ballRadius);
  if(maxDist <= 0.001) return; // nowhere to go
  slideDir.copy(dir);
  slideTarget.copy(ball.position).addScaledVector(dir, maxDist);
  sliding = true;
}
function distanceToHit(pos, dir, radius){
  // distance to arena bounds
  let dist = Infinity;
  if(dir.x > 0)  dist = Math.min(dist, (ARENA.x - radius - pos.x));
  if(dir.x < 0)  dist = Math.min(dist, (pos.x - (-ARENA.x + radius)));
  if(dir.y > 0)  dist = Math.min(dist, (ARENA.y - radius - pos.y));
  if(dir.y < 0)  dist = Math.min(dist, (pos.y - (radius)));
  if(dir.z > 0)  dist = Math.min(dist, (ARENA.z - radius - pos.z));
  if(dir.z < 0)  dist = Math.min(dist, (pos.z - (-ARENA.z + radius)));

  // distance to each box face we could hit (AABB), only along chosen axis
  for(const w of levelGroup.children){
    const g = w.geometry;
    const min = g.boundingBox.min.clone().add(w.position);
    const max = g.boundingBox.max.clone().add(w.position);

    // Check overlap on the orthogonal axes (must overlap to hit the face)
    const overlaps =
      (pos.y + radius > min.y && pos.y - radius < max.y) &&
      (pos.x + radius > min.x && pos.x - radius < max.x) &&
      (pos.z + radius > min.z && pos.z - radius < max.z);

    if(!overlaps) continue;

    if(dir.x > 0 && pos.x < min.x - radius) dist = Math.min(dist, (min.x - radius) - pos.x);
    if(dir.x < 0 && pos.x > max.x + radius) dist = Math.min(dist, pos.x - (max.x + radius));

    if(dir.y > 0 && pos.y < min.y - radius) dist = Math.min(dist, (min.y - radius) - pos.y);
    if(dir.y < 0 && pos.y > max.y + radius) dist = Math.min(dist, pos.y - (max.y + radius));

    if(dir.z > 0 && pos.z < min.z - radius) dist = Math.min(dist, (min.z - radius) - pos.z);
    if(dir.z < 0 && pos.z > max.z + radius) dist = Math.min(dist, pos.z - (max.z + radius));
  }

  return Math.max(0, dist === Infinity ? 0 : dist);
}

/* ---------- UI buttons ---------- */
document.getElementById('prevBtn').onclick = ()=>{ levelIndex = (levelIndex+makeLevels.length-1)%makeLevels.length; loadLevel(levelIndex); };
document.getElementById('nextBtn').onclick = ()=>{ levelIndex = (levelIndex+1)%makeLevels.length; loadLevel(levelIndex); };
document.getElementById('resetBtn').onclick = ()=> resetBall();

/* ---------- Helpers ---------- */
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));

/* ---------- Main loop ---------- */
let last=performance.now(), trailTimer=0;
function tick(now){
  const dt=Math.min(0.033,(now-last)/1000); last=now;

  // Slide motion toward precomputed target
  if(sliding){
    const toTarget = slideTarget.clone().sub(ball.position);
    const step = slideSpeed * dt;
    const move = Math.min(step, toTarget.length());
    if(move <= 1e-4){
      // impact
      ball.position.copy(slideTarget);
      sliding = false;
      squash = 0.18; // little squeeze on stop
    }else{
      ball.position.addScaledVector(slideDir, move);
    }
  }

  // trail & squash
  trailTimer += dt;
  if(trailTimer>0.035){ trailTimer=0; spawnTrail(); }
  for(let i=trailPool.length-1;i>=0;i--){
    const spr=trailPool[i];
    spr.userData.life-=dt;
    spr.material.opacity=Math.max(0, spr.userData.life/0.9);
    if(spr.userData.life<=0){ spr.parent.remove(spr); spr.material.dispose(); trailPool.splice(i,1); }
  }
  if(squash>0){
    const s=1+Math.sin((0.5-Math.abs(0.5-squash)/0.18)*Math.PI)*0.2;
    ball.scale.set(s,s,s); squash-=dt; if(squash<=0) ball.scale.set(1,1,1);
  }

  controls.target.lerp(ball.position,0.12);
  controls.update();
  renderer.render(scene,camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* ---------- Resize ---------- */
addEventListener('resize', ()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>



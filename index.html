<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Roller Glow — 3D Prototype</title>
<style>
  html,body{height:100%;margin:0;background:#0b0f14;color:#e8f0ff;font-family:system-ui,-apple-system,Segoe UI,Roboto}
  #ui{position:fixed;left:12px;right:12px;bottom:12px;display:flex;gap:8px;justify-content:space-between;align-items:center;pointer-events:none;z-index:5}
  .card{pointer-events:auto;background:rgba(16,22,30,.72);backdrop-filter:blur(6px);border:1px solid #203040;border-radius:12px;padding:8px 10px;box-shadow:0 6px 24px rgba(0,0,0,.35)}
  .btn{cursor:pointer;border:1px solid #2f445c;border-radius:10px;background:linear-gradient(180deg,#1a2430,#121923);color:#eaf4ff;font-weight:700;padding:8px 12px}
  .hint{opacity:.85;font-size:12px}
  canvas{display:block}
  /* simple diag banner if something fails */
  #diag{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:20px;text-align:center;background:rgba(10,14,20,.86);backdrop-filter:blur(6px);z-index:10}
  #diag .panel{max-width:860px;border:1px solid #5a2b36;background:#1a0f14;border-radius:14px;padding:18px;box-shadow:0 10px 30px #000a}
  #diag h1{margin:0 0 6px 0;font-size:20px}
  #diag p{margin:8px 0;color:#ffdbe6}
  #diag code{background:#0e141e;padding:2px 6px;border-radius:6px;border:1px solid #22354a}
</style>
</head>
<body>
<div id="ui">
  <div class="card">
    <button id="prevBtn" class="btn">Prev</button>
    <span>LEVEL <span id="levelName">1</span> / 5</span>
    <button id="nextBtn" class="btn">Next</button>
    <button id="resetBtn" class="btn">Reset</button>
  </div>
  <div class="card hint">Mouse drag = rotate • Wheel = zoom • Arrows = move • Space = up • Shift = down</div>
</div>

<div id="diag"><div class="panel">
  <h1 id="diagTitle">Diagnostics</h1>
  <p id="diagMsg">…</p>
  <p class="hint" id="diagHint"></p>
</div></div>

<script type="module">
/* ---------- Imports (CDN) ---------- */
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

/* ---------- Diagnostics helpers ---------- */
const showDiag = (title,msg,hint='')=>{
  const d=document.getElementById('diag'); d.style.display='flex';
  document.getElementById('diagTitle').textContent=title;
  document.getElementById('diagMsg').innerHTML=msg;
  document.getElementById('diagHint').innerHTML=hint;
  console.error('[Diag]', title, msg, hint);
};

// WebGL availability check (before creating renderer)
const gl2 = document.createElement('canvas').getContext('webgl2');
const gl1 = gl2 || document.createElement('canvas').getContext('webgl');
if(!gl1){
  showDiag('WebGL not available',
    'Your browser did not provide a WebGL context.',
    'Try a non-private window, or Chrome/Firefox. Ensure GPU acceleration is enabled.');
  throw new Error('No WebGL');
}

/* ---------- Scene / Camera / Renderer ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0f14);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(22, 18, 26);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

/* ---------- Controls ---------- */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.rotateSpeed = 0.8;
controls.minDistance = 8;
controls.maxDistance = 80;

/* ---------- Lights ---------- */
scene.add(new THREE.AmbientLight(0x99aabb, 0.7));
const key = new THREE.DirectionalLight(0xffffff, 0.9);
key.position.set(10,20,10); key.castShadow = true; key.shadow.mapSize.set(1024,1024);
scene.add(key);
const rim = new THREE.DirectionalLight(0x66aaff, 0.35);
rim.position.set(-12,12,-8); scene.add(rim);

/* ---------- Arena / Materials ---------- */
const ARENA = { x: 24, y: 14, z: 36 };

const floor = new THREE.Mesh(
  new THREE.BoxGeometry(ARENA.x*2, 1, ARENA.z*2),
  new THREE.MeshPhongMaterial({ color: 0x14202e, shininess: 8 })
);
floor.position.y = -0.5; floor.receiveShadow = true; scene.add(floor);

const glassMat = new THREE.MeshPhysicalMaterial({
  color: 0x84a9ff, metalness: 0.2, roughness: 0.15,
  transmission: 0.6, transparent: true, opacity: 0.35, thickness: 0.6, ior: 1.25
});
const levelGroup = new THREE.Group(); scene.add(levelGroup);
function addWall(w,h,d,x,y,z){
  const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), glassMat);
  m.position.set(x,y,z);
  m.castShadow = true; m.receiveShadow = true;
  m.geometry.computeBoundingBox(); // for collisions
  levelGroup.add(m);
  return m;
}

/* ---------- Ball (glossy + soft glow) ---------- */
const ballRadius = 1.2;
const ball = new THREE.Mesh(
  new THREE.SphereGeometry(ballRadius, 48, 32),
  new THREE.MeshPhysicalMaterial({ color: 0x45a3ff, metalness: 1, roughness: 0.15, clearcoat: 1, clearcoatRoughness: 0.06 })
);
ball.position.set(0, ballRadius, -ARENA.z + 4);
ball.castShadow = true; scene.add(ball);
ball.add(new THREE.PointLight(0x46c0ff, 0.9, 12));

controls.target.copy(ball.position);

/* ---------- Trail (fading glow sprites) ---------- */
const trailTex = (()=>{ // tiny radial gradient canvas
  const s=128, c=document.createElement('canvas'); c.width=c.height=s;
  const g=c.getContext('2d'); const r=s/2;
  const grd=g.createRadialGradient(r,r,0, r,r,r);
  grd.addColorStop(0,'rgba(120,220,255,0.9)');
  grd.addColorStop(0.5,'rgba(80,180,255,0.35)');
  grd.addColorStop(1,'rgba(0,0,0,0)');
  g.fillStyle=grd; g.fillRect(0,0,s,s);
  const tex=new THREE.CanvasTexture(c); tex.minFilter=THREE.LinearFilter; return tex;
})();
const trailGroup = new THREE.Group(); scene.add(trailGroup);
const trailPool = [];
function spawnTrail(){
  const s = 0.9 + Math.random()*0.5;
  const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: trailTex, transparent:true, depthWrite:false }));
  spr.scale.setScalar(s);
  spr.position.copy(ball.position);
  spr.position.y -= (ballRadius-0.2);
  spr.userData.life = 0.9; // seconds
  trailGroup.add(spr); trailPool.push(spr);
}

/* ---------- Input ---------- */
const keys = new Set();
addEventListener('keydown', e=>{
  if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' ','Shift'].includes(e.key)) e.preventDefault();
  keys.add(e.key);
});
addEventListener('keyup', e=> keys.delete(e.key));

/* ---------- Physics ---------- */
let vel = new THREE.Vector3();
const accel = 22, drag = 0.88, maxSpeed = 12, bounce = 0.55;
let squash = 0;

/* ---------- Levels (5 layouts) ---------- */
const baseWalls = ()=>{
  addWall(ARENA.x*2, 10, 0.8, 0, 4.5, -ARENA.z+0.4);
  addWall(ARENA.x*2, 10, 0.8, 0, 4.5,  ARENA.z-0.4);
  addWall(0.8, 10, ARENA.z*2, -ARENA.x+0.4, 4.5, 0);
  addWall(0.8, 10, ARENA.z*2,  ARENA.x-0.4, 4.5, 0);
};
const levels = [
  ()=>{ baseWalls(); addWall(2,6,2, -6,3,-10); addWall(2,6,2, 6,3,-2); addWall(2,6,2, 0,3,8); },
  ()=>{ baseWalls(); addWall(16,2,2, 0,2,-6); addWall(16,2,2, 0,6,6); addWall(2,8,10, -8,4,0); addWall(2,8,10, 8,4,0); },
  ()=>{ baseWalls(); addWall(10,2,2, -8,8,-6); addWall(10,2,2, 8,10,0); addWall(10,2,2, 0,7,8); },
  ()=>{ baseWalls(); for(let z=-12; z<=12; z+=6){ addWall(18,2,0.6, 0,3,z); addWall(18,2,0.6, 0,7,z+3);} addWall(0.6,8,18, -6,4,0); addWall(0.6,8,18, 6,4,0); },
  ()=>{ baseWalls(); const s=10,t=0.8,y=6,h=10;
    addWall(s,t,t,0,y,-s/2); addWall(s,t,t,0,y,s/2);
    addWall(t,t,s,-s/2,y,0); addWall(t,t,s,s/2,y,0);
    addWall(t,h,t,-s/2,y,-s/2); addWall(t,h,t,s/2,y,-s/2);
    addWall(t,h,t,-s/2,y,s/2);  addWall(t,h,t,s/2,y,s/2);
  }
];
let levelIndex = 0;
const levelNameEl = document.getElementById('levelName');

function clearLevel(){
  // remove meshes from levelGroup (materials shared; safe to keep)
  for(const c of [...levelGroup.children]){ levelGroup.remove(c); c.geometry.dispose(); }
}
function loadLevel(i){
  clearLevel(); levels[i]();
  ball.position.set(0, ballRadius, -ARENA.z + 4);
  vel.set(0,0,0); squash=0;
  controls.target.copy(ball.position);
  levelNameEl.textContent = (i+1);
}
loadLevel(levelIndex);

/* ---------- UI ---------- */
document.getElementById('prevBtn').onclick = ()=>{ levelIndex=(levelIndex+levels.length-1)%levels.length; loadLevel(levelIndex); };
document.getElementById('nextBtn').onclick = ()=>{ levelIndex=(levelIndex+1)%levels.length; loadLevel(levelIndex); };
document.getElementById('resetBtn').onclick = ()=> loadLevel(levelIndex);

/* ---------- Helpers ---------- */
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));

/* ---------- Simple sphere-vs-AABB collisions for walls ---------- */
function collideSphereAgainstBoxes(pos, radius){
  // test against each wall in levelGroup
  for(const w of levelGroup.children){
    const bb = w.geometry.boundingBox;
    // world-space BB (mesh only translated in this proto)
    const min = new THREE.Vector3().addVectors(bb.min, w.position);
    const max = new THREE.Vector3().addVectors(bb.max, w.position);
    // closest point on box to sphere center
    const cx = clamp(pos.x, min.x+radius, max.x-radius);
    const cy = clamp(pos.y, min.y+radius, max.y-radius);
    const cz = clamp(pos.z, min.z+radius, max.z-radius);
    if(pos.x!==cx || pos.y!==cy || pos.z!==cz){
      // push out along the deepest axis
      const dx = Math.abs(pos.x - cx), dy = Math.abs(pos.y - cy), dz = Math.abs(pos.z - cz);
      if(dx>=dy && dx>=dz){ pos.x = cx; vel.x *= -bounce; }
      else if(dy>=dx && dy>=dz){ pos.y = cy; vel.y *= -bounce; }
      else { pos.z = cz; vel.z *= -bounce; }
      squash = 0.18;
    }
  }
}

/* ---------- Main loop ---------- */
let last = performance.now();
let trailTimer = 0;

function tick(now){
  const dt = Math.min(0.033, (now-last)/1000); last = now;

  // input -> acceleration
  const dir = new THREE.Vector3(
    (keys.has('ArrowRight')?1:0) + (keys.has('ArrowLeft')?-1:0),
    (keys.has(' ')?1:0) + (keys.has('Shift')?-1:0),
    (keys.has('ArrowDown')?1:0) + (keys.has('ArrowUp')?-1:0) // +z back, -z forward
  ).normalize();

  if(dir.lengthSq()>0){
    vel.x += dir.x * accel * dt;
    vel.y += dir.y * accel * dt;
    vel.z += dir.z * accel * dt;
  }

  // speed cap & drag
  if(vel.length()>maxSpeed) vel.setLength(maxSpeed);
  vel.multiplyScalar(Math.pow(drag, dt*60));

  // integrate
  ball.position.addScaledVector(vel, dt);

  // arena bounds
  let hit=false;
  if(ball.position.x >  ARENA.x - ballRadius){ ball.position.x =  ARENA.x - ballRadius; vel.x*=-bounce; hit=true; }
  if(ball.position.x < -ARENA.x + ballRadius){ ball.position.x = -ARENA.x + ballRadius; vel.x*=-bounce; hit=true; }
  if(ball.position.y >  ARENA.y - ballRadius){ ball.position.y =  ARENA.y - ballRadius; vel.y*=-bounce; hit=true; }
  if(ball.position.y <  ballRadius){           ball.position.y =  ballRadius;           vel.y*=-bounce; hit=true; }
  if(ball.position.z >  ARENA.z - ballRadius){ ball.position.z =  ARENA.z - ballRadius; vel.z*=-bounce; hit=true; }
  if(ball.position.z < -ARENA.z + ballRadius){ ball.position.z = -ARENA.z + ballRadius; vel.z*=-bounce; hit=true; }
  if(hit) squash = 0.18;

  // internal walls
  collideSphereAgainstBoxes(ball.position, ballRadius);

  // squash & stretch
  if(squash>0){
    const s = 1 + Math.sin((0.5 - Math.abs(0.5 - squash)/0.18)*Math.PI)*0.2;
    ball.scale.set(s,s,s);
    squash -= dt;
    if(squash<=0) ball.scale.set(1,1,1);
  }

  // trail
  trailTimer += dt;
  if(trailTimer > 0.035){ trailTimer = 0; spawnTrail(); }
  for(let i=trailPool.length-1; i>=0; i--){
    const spr = trailPool[i];
    spr.userData.life -= dt;
    spr.material.opacity = Math.max(0, spr.userData.life / 0.9);
    if(spr.userData.life <= 0){
      spr.parent.remove(spr);
      spr.material.dispose();
      trailPool.splice(i,1);
    }
  }

  // camera follow + render
  controls.target.lerp(ball.position, 0.12);
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* ---------- Resize ---------- */
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>

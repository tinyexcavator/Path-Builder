<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Roller Glow — Pure WebGL</title>
<style>
  html,body{margin:0;height:100%;background:#0b0f14;color:#e8f0ff;font-family:system-ui,-apple-system,Segoe UI,Roboto}
  canvas{display:block;width:100vw;height:100vh}
  #ui{position:fixed;left:12px;right:12px;top:12px;display:flex;justify-content:space-between;align-items:center;gap:8px;z-index:5;pointer-events:none}
  .card{pointer-events:auto;background:rgba(16,22,30,.72);border:1px solid #203040;border-radius:12px;padding:8px 10px;backdrop-filter:blur(6px);box-shadow:0 6px 24px rgba(0,0,0,.35)}
  .btn{cursor:pointer;border:1px solid #2f445c;border-radius:10px;background:linear-gradient(180deg,#1a2430,#121923);color:#eaf4ff;font-weight:700;padding:8px 12px}
  .hint{opacity:.85;font-size:12px}
</style>
</head>
<body>
<div id="ui">
  <div class="card">
    <button id="prevBtn" class="btn">Prev</button>
    <span>LEVEL <span id="levelName">1</span> / 5</span>
    <button id="nextBtn" class="btn">Next</button>
    <button id="resetBtn" class="btn">Reset</button>
  </div>
  <div class="card hint">Mouse drag = rotate • Wheel = zoom • Arrows = slide • Space = up • Shift = down</div>
</div>

<canvas id="gl"></canvas>
<script>
/* -------------------- tiny math -------------------- */
const M=Float32Array;
function mat4(){return new M(16)}
function ident(o){o.set([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);return o}
function mul(a,b,out){out=out||mat4();const o=out, A=a,B=b;
  for(let r=0;r<4;r++)for(let c=0;c<4;c++)o[c+4*r]=A[0+4*r]*B[c+0]+A[1+4*r]*B[c+4]+A[2+4*r]*B[c+8]+A[3+4*r]*B[c+12];
  return o}
function translate(m,v){const t=ident(mat4());t[12]=v[0];t[13]=v[1];t[14]=v[2];return mul(m,t,mat4())}
function scale(m,v){const s=ident(mat4());s[0]=v[0];s[5]=v[1];s[10]=v[2];return mul(m,s,mat4())}
function rotateY(m,a){const c=Math.cos(a),s=Math.sin(a);const r=mat4();r.set([c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]);return mul(m,r,mat4())}
function perspective(fovy,aspect,near,far){const f=1/Math.tan(fovy/2), nf=1/(near-far);const o=mat4();
  o[0]=f/aspect;o[5]=f;o[10]=(far+near)*nf;o[11]=-1;o[14]=2*far*near*nf;return o}
function lookAt(eye,at,up){const z=norm(sub(eye,at)), x=norm(cross(up,z)), y=cross(z,x);const o=ident(mat4());
  o[0]=x[0];o[1]=y[0];o[2]=z[0];
  o[4]=x[1];o[5]=y[1];o[6]=z[1];
  o[8]=x[2];o[9]=y[2];o[10]=z[2];
  o[12]=-dot(x,eye);o[13]=-dot(y,eye);o[14]=-dot(z,eye);return o}
function add(a,b){return [a[0]+b[0],a[1]+b[1],a[2]+b[2]]}
function sub(a,b){return [a[0]-b[0],a[1]-b[1],a[2]-b[2]]}
function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]}
function cross(a,b){return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]}
function len(a){return Math.hypot(a[0],a[1],a[2])}
function norm(a){const l=len(a)||1;return [a[0]/l,a[1]/l,a[2]/l]}

/* -------------------- WebGL boot -------------------- */
const canvas=document.getElementById('gl');
const gl=canvas.getContext('webgl',{alpha:false,antialias:true});
if(!gl){ alert('WebGL not available'); }

function resize(){const dpr=window.devicePixelRatio||1; canvas.width=innerWidth*dpr; canvas.height=innerHeight*dpr;
  canvas.style.width='100vw'; canvas.style.height='100vh'; gl.viewport(0,0,canvas.width,canvas.height); }
addEventListener('resize',resize); resize();

/* -------------------- shaders -------------------- */
const VERT=`
attribute vec3 aPos;
attribute vec3 aNormal;
uniform mat4 uM,uVP;
uniform vec3 uColor;
varying vec3 vN;
varying vec3 vW;
varying vec3 vColor;
void main(){
  vec4 wPos = uM * vec4(aPos,1.0);
  gl_Position = uVP * wPos;
  vN = mat3(uM) * aNormal;
  vW = wPos.xyz;
  vColor = uColor;
}`;
const FRAG=`
precision mediump float;
varying vec3 vN;
varying vec3 vW;
varying vec3 vColor;
uniform vec3 uLightDir;
uniform float uAlpha;
void main(){
  vec3 N = normalize(vN);
  float NdL = max(dot(N, normalize(-uLightDir)), 0.05);
  vec3 base = vColor * (0.25 + 0.75*NdL);
  gl_FragColor = vec4(base, uAlpha);
}`;
function compile(type,src){const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s;}
const prog=gl.createProgram();
gl.attachShader(prog,compile(gl.VERTEX_SHADER,VERT));
gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,FRAG));
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
gl.useProgram(prog);

const loc={
  aPos:gl.getAttribLocation(prog,'aPos'),
  aNormal:gl.getAttribLocation(prog,'aNormal'),
  uM:gl.getUniformLocation(prog,'uM'),
  uVP:gl.getUniformLocation(prog,'uVP'),
  uColor:gl.getUniformLocation(prog,'uColor'),
  uLightDir:gl.getUniformLocation(prog,'uLightDir'),
  uAlpha:gl.getUniformLocation(prog,'uAlpha'),
};

/* -------------------- geometry helpers -------------------- */
function makeBox(w,h,d){
  const x=w/2,y=h/2,z=d/2;
  const p=[ // positions
    // +x
    x,-y,-z, x, y,-z, x, y, z,  x,-y,-z, x, y, z, x,-y, z,
    // -x
   -x,-y,-z,-x,-y, z,-x, y, z, -x,-y,-z,-x, y, z,-x, y,-z,
    // +y
   -x, y,-z,-x, y, z, x, y, z, -x, y,-z, x, y, z, x, y,-z,
    // -y
   -x,-y,-z, x,-y,-z, x,-y, z, -x,-y,-z, x,-y, z,-x,-y, z,
    // +z
   -x,-y, z, x,-y, z, x, y, z, -x,-y, z, x, y, z,-x, y, z,
    // -z
   -x,-y,-z,-x, y,-z, x, y,-z, -x,-y,-z, x, y,-z, x,-y,-z
  ];
  const n=[ // normals
    1,0,0, 1,0,0, 1,0,0, 1,0,0, 1,0,0, 1,0,0,
   -1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,
    0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,1,0,
    0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,
    0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1,
    0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1
  ];
  return {pos:new Float32Array(p), nor:new Float32Array(n), count:36};
}
function makeSphere(r, seg=24, rings=16){
  const pos=[], nor=[];
  for(let j=0;j<rings;j++){
    const v1=j/rings, v2=(j+1)/rings;
    const phi1=(v1-0.5)*Math.PI, phi2=(v2-0.5)*Math.PI;
    for(let i=0;i<seg;i++){
      const u1=i/seg,u2=(i+1)/seg;
      const th1=u1*2*Math.PI, th2=u2*2*Math.PI;
      const q=[
        sph(th1,phi1), sph(th2,phi1),
        sph(th2,phi2), sph(th1,phi2),
      ];
      // two tris
      pushTri(q[0],q[1],q[2]);
      pushTri(q[0],q[2],q[3]);
    }
  }
  function sph(th,ph){ return [Math.cos(th)*Math.cos(ph), Math.sin(ph), Math.sin(th)*Math.cos(ph)]; }
  function pushTri(a,b,c){
    [a,b,c].forEach(v=>{ pos.push(r*v[0], r*v[1], r*v[2]); nor.push(v[0],v[1],v[2]); });
  }
  return {pos:new Float32Array(pos), nor:new Float32Array(nor), count:pos.length/3};
}

/* -------------------- buffers -------------------- */
function makeVAO(geo){
  const vao=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,vao);
  const interleaved=new Float32Array(geo.pos.length+geo.nor.length);
  for(let i=0,j=0;i<geo.pos.length/3;i++,j+=6){
    interleaved[j]=geo.pos[i*3+0]; interleaved[j+1]=geo.pos[i*3+1]; interleaved[j+2]=geo.pos[i*3+2];
    interleaved[j+3]=geo.nor[i*3+0]; interleaved[j+4]=geo.nor[i*3+1]; interleaved[j+5]=geo.nor[i*3+2];
  }
  gl.bufferData(gl.ARRAY_BUFFER,interleaved,gl.STATIC_DRAW);
  const stride=24;
  gl.enableVertexAttribArray(loc.aPos); gl.vertexAttribPointer(loc.aPos,3,gl.FLOAT,false,stride,0);
  gl.enableVertexAttribArray(loc.aNormal); gl.vertexAttribPointer(loc.aNormal,3,gl.FLOAT,false,stride,12);
  return {buf:vao, count:geo.count};
}

const boxVAO=makeVAO(makeBox(1,1,1));
const sphereVAO=makeVAO(makeSphere(1.0,28,18));

/* -------------------- scene objects -------------------- */
const ARENA={x:24,y:14,z:36};
function wall(w,h,d,x,y,z){ walls.push({w,h,d,x,y,z}); }
let walls=[];

function buildLevel(i){
  walls=[];
  // perimeter
  wall(ARENA.x*2,10,0.8, 0,4.5,-ARENA.z+0.4);
  wall(ARENA.x*2,10,0.8, 0,4.5, ARENA.z-0.4);
  wall(0.8,10,ARENA.z*2,-ARENA.x+0.4,4.5,0);
  wall(0.8,10,ARENA.z*2, ARENA.x-0.4,4.5,0);

  // inner
  const L = [
    ()=>{ wall(8,2,2,-10,2,-12); wall(8,2,2,10,2,-6); wall(8,2,2,0,2,2); wall(8,2,2,-10,6,10); wall(8,2,2,10,8,14); wall(2,8,10,0,4,-18); },
    ()=>{ wall(18,2,0.8,0,3,-12); wall(18,2,0.8,0,7,-6); wall(18,2,0.8,0,3,6); wall(18,2,0.8,0,7,12); wall(0.8,8,12,-8,4,0); wall(0.8,8,12,8,4,0); },
    ()=>{ wall(10,2,2,-8,8,-12); wall(10,2,2,8,10,-4); wall(10,2,2,0,7,10); wall(2,8,8,0,4,0); },
    ()=>{ for(let z=-12;z<=12;z+=6){ wall(18,2,0.6,0,3,z); wall(18,2,0.6,0,7,z+3);} wall(0.6,8,18,-6,4,0); wall(0.6,8,18,6,4,0); wall(8,2,2,-12,2,-16); wall(8,2,2,12,2,16); },
    ()=>{ const s=10,t=0.8,h=10,y=6; wall(s,t,t,0,y,-s/2); wall(s,t,t,0,y,s/2); wall(t,t,s,-s/2,y,0); wall(t,t,s,s/2,y,0); wall(t,h,t,-s/2,y,-s/2); wall(t,h,t,s/2,y,-s/2); wall(t,h,t,-s/2,y,s/2); wall(t,h,t,s/2,y,s/2); }
  ];
  L[i]();
}
let level=0; buildLevel(level);
document.getElementById('levelName').textContent=level+1;

/* ball */
const radius=1.2;
let ballPos=[0,radius,-ARENA.z+4];
let sliding=false, slideDir=[0,0,0], slideTarget=[0,0,0];
function resetBall(){ ballPos=[0,radius,-ARENA.z+4]; sliding=false; }

/* -------------------- input: one-tap slide -------------------- */
const keyDir = {
  ArrowLeft:[-1,0,0], ArrowRight:[1,0,0],
  ArrowUp:[0,0,-1], ArrowDown:[0,0,1],
  'Space':[0,1,0], 'Shift':[0,-1,0]
};
addEventListener('keydown',e=>{
  let k=e.key===' '? 'Space' : (e.key.startsWith('Shift')?'Shift':e.key);
  const d=keyDir[k]; if(!d) return; e.preventDefault();
  if(sliding) return;
  startSlide(d);
});
function startSlide(dir){
  const max=distanceToHit(ballPos,dir,radius);
  if(max<=1e-4) return;
  slideDir=[...dir];
  slideTarget=[ ballPos[0]+dir[0]*max, ballPos[1]+dir[1]*max, ballPos[2]+dir[2]*max ];
  sliding=true;
}
function distanceToHit(p,d,r){
  let dist=Infinity;
  // bounds
  if(d[0]>0) dist=Math.min(dist, (ARENA.x-r - p[0]));
  if(d[0]<0) dist=Math.min(dist, (p[0] - (-ARENA.x+r)));
  if(d[1]>0) dist=Math.min(dist, (ARENA.y-r - p[1]));
  if(d[1]<0) dist=Math.min(dist, (p[1] - (r)));
  if(d[2]>0) dist=Math.min(dist, (ARENA.z-r - p[2]));
  if(d[2]<0) dist=Math.min(dist, (p[2] - (-ARENA.z+r)));
  // walls
  for(const w of walls){
    const min=[w.x-w.w/2, w.y-w.h/2, w.z-w.d/2];
    const max=[w.x+w.w/2, w.y+w.h/2, w.z+w.d/2];
    const overlaps = (p[1]+r>min[1] && p[1]-r<max[1]) && (p[0]+r>min[0] && p[0]-r<max[0]) && (p[2]+r>min[2] && p[2]-r<max[2]);
    if(!overlaps) continue;
    if(d[0]>0 && p[0] < min[0]-r) dist=Math.min(dist, (min[0]-r) - p[0]);
    if(d[0]<0 && p[0] > max[0]+r) dist=Math.min(dist, p[0] - (max[0]+r));
    if(d[1]>0 && p[1] < min[1]-r) dist=Math.min(dist, (min[1]-r) - p[1]);
    if(d[1]<0 && p[1] > max[1]+r) dist=Math.min(dist, p[1] - (max[1]+r));
    if(d[2]>0 && p[2] < min[2]-r) dist=Math.min(dist, (min[2]-r) - p[2]);
    if(d[2]<0 && p[2] > max[2]+r) dist=Math.min(dist, p[2] - (max[2]+r));
  }
  return Math.max(0, dist===Infinity?0:dist);
}

/* -------------------- camera (orbit) -------------------- */
let camDist=34, theta=0.9, phi=0.9; // spherical
let isDrag=false, lastX=0,lastY=0;
canvas.addEventListener('mousedown',e=>{isDrag=true; lastX=e.clientX; lastY=e.clientY;});
addEventListener('mouseup',()=>isDrag=false);
addEventListener('mousemove',e=>{
  if(!isDrag) return;
  const dx=(e.clientX-lastX)/canvas.clientWidth, dy=(e.clientY-lastY)/canvas.clientHeight;
  lastX=e.clientX; lastY=e.clientY;
  theta-=dx*3.0; phi-=dy*3.0; phi=Math.max(0.2, Math.min(2.7, phi));
});
canvas.addEventListener('wheel',e=>{ camDist*= (1+Math.sign(e.deltaY)*0.08); camDist=Math.max(10,Math.min(90,camDist)); });

function camEye(){
  const x=ballPos[0]+camDist*Math.sin(phi)*Math.cos(theta);
  const y=ballPos[1]+camDist*Math.cos(phi);
  const z=ballPos[2]+camDist*Math.sin(phi)*Math.sin(theta);
  return [x,y,z];
}

/* -------------------- UI buttons -------------------- */
document.getElementById('prevBtn').onclick=()=>{ level=(level+4)%5; buildLevel(level); resetBall(); document.getElementById('levelName').textContent=level+1; };
document.getElementById('nextBtn').onclick=()=>{ level=(level+1)%5; buildLevel(level); resetBall(); document.getElementById('levelName').textContent=level+1; };
document.getElementById('resetBtn').onclick=()=>{ resetBall(); };

/* -------------------- render helpers -------------------- */
gl.enable(gl.DEPTH_TEST);
gl.enable(gl.CULL_FACE);
gl.cullFace(gl.BACK);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

function drawMesh(vao, model, color, alpha){
  gl.uniformMatrix4fv(loc.uM,false,model);
  gl.uniform3fv(loc.uColor,color);
  gl.uniform1f(loc.uAlpha,alpha);
  gl.bindBuffer(gl.ARRAY_BUFFER, vao.buf);
  gl.drawArrays(gl.TRIANGLES,0,vao.count);
}

/* -------------------- main loop -------------------- */
let last=performance.now();
function loop(now){
  const dt=Math.min(0.033,(now-last)/1000); last=now;

  // slide movement
  if(sliding){
    const speed=28, step=speed*dt;
    const to=[slideTarget[0]-ballPos[0], slideTarget[1]-ballPos[1], slideTarget[2]-ballPos[2]];
    const dist=len(to);
    if(dist<=step){ ballPos=[...slideTarget]; sliding=false; } else {
      ballPos=[ ballPos[0]+slideDir[0]*step, ballPos[1]+slideDir[1]*step, ballPos[2]+slideDir[2]*step ];
    }
  }

  gl.clearColor(0.043,0.059,0.078,1); gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

  const aspect=canvas.width/canvas.height;
  const P=perspective(60*Math.PI/180, aspect, 0.1, 1000);
  const eye=camEye(), at=ballPos, up=[0,1,0];
  const V=lookAt(eye,at,up);
  const VP=mul(P,V,mat4());

  gl.uniformMatrix4fv(loc.uVP,false,VP);
  gl.uniform3fv(loc.uLightDir,[ -0.6, 1.0, 0.4 ]);

  // floor
  let M=ident(mat4());
  M=scale(M,[ARENA.x*2,1,ARENA.z*2]); M=translate(M,[0,-0.5,0]);
  drawMesh(boxVAO,M,[0.08,0.12,0.18],1.0);

  // glass walls (enable blending)
  gl.enable(gl.BLEND);
  for(const w of walls){
    let Mw=ident(mat4()); Mw=scale(Mw,[w.w,w.h,w.d]); Mw=translate(Mw,[w.x,w.y,w.z]);
    drawMesh(boxVAO,Mw,[0.55,0.71,1.0],0.35);
  }
  gl.disable(gl.BLEND);

  // ball
  let Mb=ident(mat4()); Mb=scale(Mb,[radius,radius,radius]); Mb=translate(Mb,ballPos);
  drawMesh(sphereVAO,Mb,[0.27,0.64,1.0],1.0);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
